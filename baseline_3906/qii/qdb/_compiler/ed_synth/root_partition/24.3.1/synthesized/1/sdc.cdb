22 serialization::archive 19 0 0 0 0 4 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 0 0 17 0 0 0 8 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 8 ed_synth 28 altera_reset_controller_1924 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 28 ed_synth_emif_io96b_lpddr4_0 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 28 ed_synth_emif_io96b_lpddr4_0 28 altera_reset_controller_1924 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 28 ed_synth_emif_io96b_lpddr4_0 21 emif_io96b_lpddr4_200 5 synth 62 ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq.sdc 15359 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing constraints of the memory device and
# of the memory interface
 
# ------------------------------------------- #
# -                                         - #
# --- Some useful functions and variables --- #
# -                                         - #
# ------------------------------------------- #
 
set script_dir [file dirname [info script]]
source "$script_dir/ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_timing_parameters.tcl"
source "$script_dir/ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_timing_pins.tcl"
 
#--------------------------------------------#
# -                                        - #
# --- Determine when SDC is being loaded --- #
# -                                        - #
#--------------------------------------------#
 
set syn_flow 0
set sta_flow 0
set fit_flow 0
set pow_flow 0
if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
   set syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
   set sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
   set fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
   set pow_flow 1
}
set ::io_only_analysis 0
 
# ------------------------ #
# -                      - #
# --- GENERAL SETTINGS --- #
# -                      - #
# ------------------------ #
 
# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty
 
# Debug switch. Change to 1 to get more run-time debug information
set debug 0
 
# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3
 
# Determine if entity names are on
set entity_names_on [ emif_are_entity_names_on ]
 
# ---------------------- #
# -                    - #
# --- DERIVED TIMING --- #
# -                    - #
# ---------------------- #
 
# PLL multiplier to mem clk
#regexp {([0-9\.]+) ps} $var(PLL_REF_CLK_FREQ_PS_STR) match var(PHY_REF_CLK_FREQ_PS)
set vco_freq [ emif_round_3dp [expr $var(MEM_OPERATING_FREQ_MHZ)*$var(CLK_DIV_VCO_MEM)]]
set phy_freq [ emif_round_3dp [expr $var(MEM_OPERATING_FREQ_MHZ)/$var(CLK_DIV_MEM_PHY)]]
set vco_multiplier [emif_round_3dp [expr $vco_freq/$var(PHY_REFCLK_FREQ_MHZ)]]


# Half of memory clock cycle
#set half_period [ emif_round_3dp [ expr $var(UI) / 2.0 ] ]
 
# Half of reference clock
#set ref_period      [ emif_round_3dp [ expr $var(PHY_REF_CLK_FREQ_PS)/1000.0] ]
 
# Other clock periods
#set tCK_AFI     [ emif_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(USER_CLK_RATIO) ] ]
 
# Asymmetric uncertainties on address and command paths
#set ac_min_delay [ emif_round_3dp [ expr - $var(tIH) + $var(CA_TO_CK_BD_PKG_SKEW) ]]
 
# ---------------------- #
# -                    - #
# --- INTERFACE RATE --- #
# -                    - #
# ---------------------- #
 
# -------------------------------------------------------------------- #
# -                                                                  - #
# --- This is the main call to the netlist traversal routines      --- #
# --- that will automatically find all pins and registers required --- #
# --- to apply timing constraints.                                 --- #
# --- During the fitter, the routines will be called only once     --- #
# --- and cached data will be used in all subsequent calls.        --- #
# -                                                                  - #
# -------------------------------------------------------------------- #
 
if { ! [ info exists ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_sdc_cache ] } {
   emif_initialize_ddr_db ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_emif_ddr_db var
   set ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_sdc_cache 1
} else {
   if { $debug } {
      post_message -type info "SDC: reusing cached DDR DB"
   }
}
 
# ------------------------------------------------------------- #
# -                                                           - #
# --- If multiple instances of this core are present in the --- #
# --- design they will all be constrained through the       --- #
# --- following loop                                        --- #
# -                                                           - #
# ------------------------------------------------------------- #
 
set instances [ array names ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_emif_ddr_db ]
foreach { inst } $instances {
   if { [ info exists pins ] } {
      unset pins
   }
   array set pins $ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_emif_ddr_db($inst)

   # ----------------------- #
   # -                     - #
   # --- REFERENCE CLOCK --- #
   # -                     - #
   # ----------------------- #
 
   # First determine if a reference clock has already been created (i.e. Reference clock sharing)
   set ref_clock_exists [ emif_does_ref_clk_exist $pins(pll_ref_clock) ]
   if { $ref_clock_exists == 0 }  {
      # This is the reference clock used by the PLL to derive any other clock in the core
      if {$var(LOCKSTEP_ROLE) eq "OFF"} {
        create_clock -period "$var(PHY_REFCLK_FREQ_MHZ)MHz" $pins(pll_ref_clock) -add -name ${inst}_ref_clock
      } else {
        create_clock -period "$var(PHY_REFCLK_FREQ_MHZ)MHz" $pins(pll_ref_clock) -add -name $pins(pll_ref_clock)
      }
   }
   
   set pins(ref_clock_name) [emif_get_clock_name_from_pin_name $pins(pll_ref_clock)]
   # NCNTR clock division
   set pll_ncntr_clk [emif_get_or_add_generated_clock \
      -target $pins(pll_ncntr) \
      -name ${inst}_pll_ncntr \
      -source $pins(pll_ref_clock) \
      -multiply_by 1 \
      -divide_by $var(PLL_N_DIV) \
      -phase 0 ]

    if {$var(PLL_N_DIV)==1} {
       set srcclk $pins(pll_ref_clock)
    } else {
       set srcclk $pins(pll_ncntr)
    }

   # VCO clock
   set i_vco_clock 0
   foreach { vco_clock } $pins(pll_vco_clock) vco_base $pins(vco_base_node) {
 
      emif_get_or_add_generated_clock -target $vco_base \
         -name "${inst}_vco_base_${i_vco_clock}" \
         -source $srcclk \
         -multiply_by $var(PLL_M_DIV)  \
         -divide_by 1 \
         -phase 0 
 
      incr i_vco_clock
   }
   set i_vco_clock 0
   foreach { vco_clock } $pins(pll_vco_periph_clock) vco_base $pins(vco_base_node) {
      set local_pll_vco_clk__p${i_vco_clock} [ emif_get_or_add_generated_clock \
         -target $vco_clock \
         -name "${inst}_vco_clk_periph_${i_vco_clock}" \
         -source $srcclk \
         -multiply_by $var(PLL_M_DIV)  \
         -divide_by 1 \
         -phase 0 ]
      incr i_vco_clock
   }

   # Periphery clocks
   set periphery_clocks [list]
   set i_phy_clock 0
   foreach { phy_clock } $pins(pll_phy_clock) phy_reg $pins(pll_phy_reg) {
      set divide_by [expr {$var(CLK_DIV_VCO_MEM) * $var(CLK_DIV_MEM_PHY)}]
      set phase 0 ;
      emif_get_or_add_generated_clock -target $phy_reg \
         -name "${inst}_c0_cntr_${i_phy_clock}" \
         -source [lindex $pins(vco_base_node) $i_phy_clock] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase

      set local_phy_clk_${i_phy_clock} [ emif_get_or_add_generated_clock \
         -target $phy_clock \
         -name "${inst}_phy_clk_${i_phy_clock}" \
         -source $phy_reg \
         -multiply_by 1 \
         -divide_by 1 \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_${i_phy_clock}]
      incr i_phy_clock
   }
 
   set i_phy_clock_l 0
   foreach { phy_clock_l } $pins(pll_phy_clock_sync) phy_reg_s $pins(pll_phy_reg_sync) {
      set divide_by $var(PLL_C_DIV_1)
      set phase 0
      emif_get_or_add_generated_clock -target $phy_reg_s \
         -name "${inst}_c1_cntr_${i_phy_clock_l}" \
         -source [lindex $pins(vco_base_node) $i_phy_clock_l] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase
 
      set local_phy_clk_sync_${i_phy_clock_l} [ emif_get_or_add_generated_clock \
         -target $phy_clock_l \
         -name "${inst}_phy_clk_sync_${i_phy_clock_l}" \
         -source $phy_reg_s \
         -multiply_by 1 \
         -divide_by 1 \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_sync_${i_phy_clock_l}]
      incr i_phy_clock_l
   }
   
   set usr_clock ""
   if {!($var(PHY_NOC_EN) || $var(MEM_CLK_ASYNC) || ($var(LOCKSTEP_ROLE) ne "OFF" && [regexp "1\$" $inst]))} {
      set phase 0
 
      set usr_clock [ emif_get_or_add_generated_clock \
         -target $pins(cpa_clock) \
         -name "${inst}_usr_clk" \
         -source [lindex $pins(vco_base_node) 0] \
         -multiply_by 1 \
         -divide_by $var(CLK_DIV_VCO_CORE) \
         -phase $phase ]
   }

   # WRITE_CLK
   foreach {dqs_t} $pins(dqs_t) {

      set_false_path -to [get_ports $dqs_t]
      set_false_path -from [get_ports $dqs_t]

      create_clock -period "${vco_freq}MHz" $dqs_t -name "${inst}_${dqs_t}_in" -add

      disable_min_pulse_width ${inst}_${dqs_t}_in
   }

   # READ_CLK
#set rclk_idx 0

   if {[regexp "_DDR4" $var(MEM_TECHNOLOGY)]} {
      set fa_div 2
   } else {
      set fa_div 4
   }
   foreach {fa_phyclk} $pins(phyclk_div) {
      emif_get_or_add_generated_clock \
         -target [lindex $fa_phyclk 0] \
         -name "${inst}_fa_[lindex $fa_phyclk 1]_[lindex $fa_phyclk 2]_[lindex $fa_phyclk 3]" \
         -source [lindex $pins(pll_phy_clock) 0] \
         -multiply_by 1 \
         -divide_by $fa_div \
         -phase 0
   }

   set lane 0
   foreach { phy_rxclk_gated } $pins(phy_rxclk_gated) byte_rx_gated $pins(byte_rx_gated) {
      create_clock -name "${inst}_lane_${lane}_rxclk_gated" -period 10.000 $phy_rxclk_gated
      set lane_${lane}_byte_rx_gated [ emif_get_or_add_generated_clock \
         -target $byte_rx_gated \
         -name "${inst}_lane_${lane}_byte_rx_gated" \
         -source $phy_rxclk_gated \
         -multiply_by 1 \
         -divide_by 1 \
         -phase 0 ]
      set_false_path -from [get_clocks "${inst}_lane_${lane}_byte_rx_gated"]
      incr lane
   }
   foreach t $pins(dqs_t) n $pins(dqsn_nff) {
      create_generated_clock \
         -name "${inst}_${t}_nff" \
         -source $t \
         -invert \
         $n
      set_false_path -from [get_clocks "${inst}_${t}_nff"]
   }
   foreach mipi $pins(mipi_div) {
      disable_min_pulse_width $mipi
   }
   
   # LOCKSTEP
   if {$var(LOCKSTEP_ROLE) ne "OFF" && [regexp "1\$" $inst]} {
	     set ls_inst [regsub "_1\$" $inst {}]
        if ${sta_flow} {
            set_min_delay -10 -from [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_mcp*]
            set_max_delay  10 -from [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_mcp*]
            set_data_delay -from [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_mcp*] -get_value_from_clock_period dst_clock_period -no_synchronizer -value_multiplier 2
        } else { 
            set_min_delay -5 -from [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_mcp*]
            set_max_delay  5 -from [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_mcp*]
            set_data_delay -from [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_mcp*] -get_value_from_clock_period dst_clock_period -no_synchronizer -value_multiplier 1
        }
        emif_add_false_path $sta_flow 5 -to [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_sync_inst|din_s1]
        set_data_delay -to [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*_sync_inst|din_s1] -get_value_from_clock_period dst_clock_period -value_multiplier 1
        emif_add_false_path $sta_flow 10 -to [get_keepers ${ls_inst}|lockstep.ls_sideband_adaptor|*|*rst*_sync_inst|*]
        set_false_path -from  [get_keepers ${ls_inst}|*|AXIL_ADAPTOR.adaptor_inst|*hipi_c2p|inst] -to [get_keepers ${ls_inst}|*|wrapper_pll|pll~out_clk_periph0_reg]
        set_false_path -from  [get_keepers ${ls_inst}|*|AXIL_ADAPTOR.adaptor_inst|*hipi_c2p*] -to [get_keepers ${ls_inst}|*|wrapper_pll|pll~out_clk_periph0_reg]
    }
   # DQ/DQS pins are calibrated
   if {[llength $pins(dq)] > 0} {
      set_false_path -to $pins(dq)
      set_false_path -from $pins(dq)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dq) -add
      set_input_delay -clock $pins(ref_clock_name) 0 $pins(dq) -add
   }
   if {[llength $pins(dm)] > 0} {
      set_false_path -to $pins(dm)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dm) -add
   }
   if {[llength $pins(dbi)] > 0} {
      set_false_path -to $pins(dbi)
      set_false_path -from $pins(dbi)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dbi) -add
      set_input_delay -clock $pins(ref_clock_name) 0 $pins(dbi) -add
   }
   if {[llength $pins(wclk)] > 0} {
      set_false_path -to $pins(wclk)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk) -add
   }
   if {[llength $pins(rclk)] > 0} {
      set_false_path -from $pins(rclk)
   }
   if {[llength $pins(ac_clk)] > 0} {
      set_false_path -to $pins(ac_clk)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk) -add
   }
   if {[llength $pins(ac_async)] > 0} {
      set_false_path -to $pins(ac_async)
      set_false_path -from $pins(ac_async)
      foreach ac_async $pins(ac_async) {
         if {[string match "*alert*" $ac_async]} {
            set_input_delay -clock $pins(ref_clock_name) 0 $ac_async -add
         }
         if {[string match "*reset*" $ac_async]} {
            set_output_delay -clock $pins(ref_clock_name) 0 $ac_async -add
         }
      }
   }
   if {[llength $pins(ac_sync)] > 0} {
      set_false_path -to $pins(ac_sync)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_sync) -add
   }
}

set_false_path -to [get_registers *pa_hr_reg] -setup
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 28 ed_synth_emif_io96b_lpddr4_0 21 emif_io96b_lpddr4_200 5 synth 80 ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_timing_parameters.tcl 872 set ::GLOBAL_phy_arch_name                  ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq

set var(MEM_TECHNOLOGY)                     LPDDR4
set var(MEM_NUM_IO96)                       1
set var(PHY_REFCLK_FREQ_MHZ)                100.0
set var(MEM_OPERATING_FREQ_MHZ)             800
set var(MEM_DQ_WIDTH)                       32
set var(PHY_NOC_EN)                         0
set var(MEM_CLK_ASYNC)                      1
set var(CLK_DIV_VCO_MEM)                    1
set var(CLK_DIV_MEM_PHY)                    2
set var(PLL_C_DIV_0)                        2
set var(PLL_C_DIV_1)                        8
set var(PLL_N_DIV)                          1
set var(PLL_M_DIV)                          8
set var(CLK_DIV_VCO_CORE)                   8
set var(DQ_PER_DQS)                         8
set var(LOCKSTEP_ROLE)                      OFF
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 28 ed_synth_emif_io96b_lpddr4_0 21 emif_io96b_lpddr4_200 5 synth 74 ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_timing_pins.tcl 24726 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set script_dir [file dirname [info script]]
source "$script_dir/ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_timing_utils.tcl"
 
load_package sdc_ext
 
proc emif_get_ddr_pins { instname allpins var_array_name io_bank_inst} {
   # We need to make a local copy of the allpins associative array
   upvar allpins pins
   upvar 1 $var_array_name var
   set debug 0

   global ::GLOBAL_phy_arch_name
 
   set var(pll_inclock_search_depth) 30
   set var(pll_outclock_search_depth) 20
   set var(pll_vcoclock_search_depth) 5
 
   # ########################################
   #  1.0 find all of the PLL output clocks

   set pll_c0_periph_clock_pin_name     "out_clk_periph0";#"lvds_clk\[0\]"
   set pll_c1_periph_clock_pin_name     "out_clk_periph1";#"loaden\[0\]"
   set vco_clock_pin_name               "vcoph\[0\]";
   set vco_periph_clock_pin_name        "vco_clk_periph";
   set pll_path                         "${instname}|*.arch_${io_bank_inst}|wrapper_pll|pll";

   # Find the ncntr register in the pll
   set pins(pll_ncntr) [list]
   set pins(pll_ncntr_reg_id) [get_registers ${pll_path}*ncntr_reg]

   foreach_in_collection r $pins(pll_ncntr_reg_id) {
      set reg_name [get_register_info -name $r]
      lappend pins(pll_ncntr) [regsub -all {\\} $reg_name {\\\\}]
   }
   set pins(pll_ncntr) [emif_sort_duplicate_names $pins(pll_ncntr)]
 
   #  C0 output in the periphery
   set pins(pll_c0_periph_clock) [list]
   set pins(pll_c0_periph_reg) [list]
   set pins(pll_c0_periph_clock_pin_id) [get_pins -nowarn [list $pll_path*|$pll_c0_periph_clock_pin_name]]
 
   foreach_in_collection c $pins(pll_c0_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]
 
      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }
      lappend pins(pll_c0_periph_clock) [regsub -all {\\} $net_name {\\\\}]
      array set creg_name [list]
      emif_traverse_fanin_up_to_depth $net_name emif_is_node_type_reg clock creg_name 2 
      lappend pins(pll_c0_periph_reg) [regsub -all {\\} [get_register_info -name [lindex [array names creg_name] 0]] {\\\\}]
      array unset creg_name
   }
   set pins(pll_c0_periph_clock) [emif_sort_duplicate_names $pins(pll_c0_periph_clock)]
 
   #  C1 output in the periphery
   set pins(pll_c1_periph_clock) [list]
   set pins(pll_c1_periph_reg) [list]
   set pins(pll_c1_periph_clock_pin_id) [get_pins -nowarn [list $pll_path*|$pll_c1_periph_clock_pin_name]]
 
   foreach_in_collection c $pins(pll_c1_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]
 
      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }
 
      lappend pins(pll_c1_periph_clock) [regsub -all {\\} $net_name {\\\\}]
      array set creg_name [list]
      emif_traverse_fanin_up_to_depth $net_name emif_is_node_type_reg clock creg_name 2 
      lappend pins(pll_c1_periph_reg) [regsub -all {\\} [get_register_info -name [lindex [array names creg_name] 0]] {\\\\}]
      array unset creg_name
   }
   set pins(pll_c1_periph_clock) [emif_sort_duplicate_names $pins(pll_c1_periph_clock)]
 
   #  VCO clock (used for the system clock)
   set pins(vco_base_node) [list]
   set pins(vco_base_node_id) [get_nodes -nowarn [list ${pll_path}~vcoph\[0\]]]
   
   foreach_in_collection n $pins(vco_base_node_id) {
      set net_name [get_node_info -name $n]
 
      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $n] -> $net_name"
      }
 
      lappend pins(vco_base_node) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(vco_clock) [list]
   set pins(vco_clock_pin_id) [get_pins -nowarn [list $pll_path*~$vco_clock_pin_name]]
 
   foreach_in_collection c $pins(vco_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]
 
      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }
 
      lappend pins(vco_clock) [regsub -all {\\} $net_name {\\\\}]
   }

   #  VCO periph clock (used for the system clock)
   set pins(vco_periph_clock) [list]
   set pins(vco_periph_clock_pin_id) [get_pins -nowarn [list $pll_path*|$vco_periph_clock_pin_name]]
 
   foreach_in_collection c $pins(vco_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]
 
      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }
 
      lappend pins(vco_periph_clock) [regsub -all {\\} $net_name {\\\\}]
   }

   set pins(vco_periph_clock) [emif_sort_duplicate_names $pins(vco_periph_clock)]
   set pins(pll_vco_clock) $pins(vco_clock)
   set pins(pll_phy_clock) $pins(pll_c0_periph_clock)
   set pins(pll_phy_clock_sync) $pins(pll_c1_periph_clock)
   set pins(pll_vco_periph_clock) $pins(vco_periph_clock)
   set pins(pll_phy_reg) $pins(pll_c0_periph_reg)
   set pins(pll_phy_reg_sync) $pins(pll_c1_periph_reg)
 
   if {$debug == 1} {
     puts "VCO:           $pins(pll_vco_clock)"
     puts "PHY:           $pins(pll_phy_clock)"
     puts "PHY_SYNC:      $pins(pll_phy_clock_sync)"
     puts ""
   }
 
   #########################################
   # 2.0  Find the actual master core clock
   #      As it could come from another interface
   #      In master/slave configurations
   #
   # Skip this if we're in HPS mode as core clocks don't exist
   
   set pins(master_vco_clock) ""
   set pins(master_vco_clock_sec) ""
   set pins(master_core_usr_clock) ""
   set pins(master_core_usr_half_clock) ""
   set pins(master_core_usr_clock_sec) ""
   set pins(master_core_usr_half_clock_sec) ""
   set pins(master_core_afi_clock) ""
   set pins(master_core_dft_cpa_1_clock) ""
   set pins(master_cal_master_clk) ""
   set pins(master_cal_slave_clk) ""
   
   
   if {($var(PHY_NOC_EN) || $var(MEM_CLK_ASYNC) || ($var(LOCKSTEP_ROLE) ne "OFF" && $io_bank_inst !=0))} {
      set pins(master_instname) $instname
   } else {
      #  CPA Clock
      set pins(cpa_clock) [list]
      set pins(cpa_clock_pin_id) [get_pins -nowarn [list ${instname}|*.arch_${io_bank_inst}|wrapper_cpa|cpa|o_core_clk_out]]
 
      foreach_in_collection c $pins(cpa_clock_pin_id) {
         set pin_info [get_pin_info -net $c]
         set net_name [get_net_info -name $pin_info]
 
         if {$debug} {
            puts "CPA pin -> CPA Net: [get_node_info -name $c] -> $net_name"
         }
 
         lappend pins(cpa_clock) [regsub -all {\\} $net_name {\\\\}]
      }
   }

   set pins(i_phyclk_div_reg) [get_registers ${instname}|*.arch_${io_bank_inst}*div_reg]
   set pins(phyclk_div) [list]
   set pins(mipi_div) [list]
   foreach_in_collection r $pins(i_phyclk_div_reg) {
      set reg_name [get_register_info -name $r]
      if {[regexp hmc $reg_name]} {
         set hmclane "hmc" 
         if {[regexp wide $reg_name]} {
            set idx "wide"
         } else {
            set idx "slim"
         }
      } elseif {[regexp ssm $reg_name]}  {
         set hmclane "ssm"
         set idx ${io_bank_inst}
      } else {
         set hmclane "lane"
         regexp -expanded {gen_byte_conns\[(\d)\]} $reg_name {} idx
      }
      if {[regexp p2c $reg_name]} {
         set dir "p2c"
      } else {
         set dir "c2p"
      }
      if {![regexp mipi_div_reg $reg_name]} {
         lappend pins(phyclk_div) [list $reg_name $hmclane $idx $dir]
      } else {
         lappend pins(mipi_div) $reg_name
      }
   }

 
   # ########################################
   #  2.5 Find the reference clock input of the PLL
 
   set pins(pll_refclk_in) [get_pins -compatibility_mode ${pll_path}|ref_clk0]
   set pll_ref_clock_id [emif_get_input_clk_id $pins(pll_refclk_in) var]
   if {$pll_ref_clock_id == -1} {
      post_message -type critical_warning "emif_pin_map.tcl: Failed to find PLL reference clock"
   } else {
      set pll_ref_clock [get_node_info -name $pll_ref_clock_id]
   }
   set pins(pll_ref_clock) $pll_ref_clock
 
   if {$debug == 1} {
     puts "REF:     $pins(pll_ref_clock)"
     puts ""
   }
 
##########################################
## 3.0  find the FPGA pins
## The hierarchy paths to all the pins are stored in the *_ip_parameters.tcl
## file which is a generated file. Pins are divided into the following
## protocol-agnostic categories. For each pin category, we need to
## fully-resolve the hierarchy path patterns and store the results into
## the "pins" arrays.
#
    set pins(dqs_t) [emif_traverse_node_fanout_path $pins(vco_periph_clock) dqs_t 10]
    set pins(dqs_t_in) [get_nodes  ${instname}|*bufs_mem*DQS*ibuf|i]
    set pins(rclk) [list]
    set dqs_t_empty [expr {[llength $pins(dqs_t)] == 0 }]
    if { $dqs_t_empty } { set pins(dqs_t) [list] }
    foreach_in_collection n $pins(dqs_t_in) {
       lappend pins(rclk) [get_node_info -name $n]
       if { $dqs_t_empty } {
         array set dqs_t_arr [list]
         emif_traverse_fanin_up_to_depth $n emif_is_node_type_pin clock dqs_t_arr 2
         if {[array size dqs_t_arr] == 1} {
            lappend pins(dqs_t) [get_node_info -name [lindex [array names dqs_t_arr] 0]]
         } 
         array unset dqs_t_arr
      }
    }

   set pin_categories [list ac_clk \
                            ac_sync \
                            ac_async \
                            rclk \
                            wclk \
                            dq \
                            dm \
                            dbi ]

   foreach pc $pin_categories {
      set pins($pc) [list]
   }
   foreach obuf [emif_traverse_node_fanout_path $pins(vco_periph_clock) ".*g_MEM.*obuf\\|o" 10 ] {
      set oport [get_ports [emif_traverse_node_fanout_path $obuf ".*" 2]]
      if {[regexp "MEM_CK_" $obuf]} {
         foreach p [emif_get_names_in_collection $oport] {lappend pins(ac_clk) $p}
      } elseif {[regexp "MEM_CKE_" $obuf] || [regexp "MEM_ODT_" $obuf] || [regexp "MEM_CS_" $obuf] || \
                [regexp "MEM_A_" $obuf] || [regexp "MEM_BA_" $obuf] || [regexp "MEM_BG_" $obuf] || \
                [regexp "MEM_ACT_N_" $obuf] || [regexp "MEM_PAR_" $obuf] || [regexp "MEM_CA_" $obuf] || \
                [regexp "MEM_C" $obuf]} {
         foreach p [emif_get_names_in_collection $oport] {lappend pins(ac_sync) $p}
      } elseif {[regexp "MEM_RESET_N_" $obuf] } { 
         foreach p [emif_get_names_in_collection $oport] {lappend pins(ac_async) $p}
      } elseif {[regexp "MEM_DQS_" $obuf] || [regexp "MEM_RDQS_" $obuf] || [regexp "MEM_WCK_" $obuf]} {
         if {[regexp "MEM_DQS_" $obuf] || [regexp "MEM_RDQS_" $obuf]} {
            foreach p [emif_get_names_in_collection $oport] {lappend pins(rclk) $p}
         }
         if {[regexp "MEM_DQS_" $obuf] || [regexp "MEM_WCK_" $obuf]} {
            foreach p [emif_get_names_in_collection $oport] {lappend pins(wclk) $p}
         }
      } elseif {[regexp "MEM_DQ_" $obuf]} {
         foreach p [emif_get_names_in_collection $oport] {lappend pins(dq) $p}
      } elseif {[regexp "MEM_DM_" $obuf]} {
         foreach p [emif_get_names_in_collection $oport] {lappend pins(dm) $p}
      } elseif {[regexp "MEM_DMI_" $obuf] || [regexp "MEM_DBI_" $obuf]} {
         foreach p [emif_get_names_in_collection $oport] {lappend pins(dbi) $p}
      } else {
         post_message -type warning "emif_pin_map.tcl: couldn't match $obuf to a pin type! ([foreach_in_collection p $oport {puts [get_port_info -name $p]}])"
      }

   } 

##########################################
## 4.0 Miscellanea
   set pins(phy_rxclk_gated) [list]
   set pins(phy_rxclk_gated_id) [get_pins -compatibility_mode "${instname}|*.arch_${io_bank_inst}*i_phy_rxclk_gated*"]
   set pins(dqsn_nff) [list]
 
   foreach_in_collection n $pins(phy_rxclk_gated_id) {
      set node_name [get_node_info -name $n]
      lappend pins(phy_rxclk_gated) [regsub -all {\\} $node_name {\\\\}]
   }
   set pins(phy_rxclk_gated) [lsort $pins(phy_rxclk_gated)]
 
   set pins(byte_rx_gated) [list]
   set pins(byte_rx_gated_id) [get_registers "${instname}|*.arch_${io_bank_inst}*byte_rx_gated_reg*"]
 
   foreach_in_collection n $pins(byte_rx_gated_id) {
      set node_name [get_node_info -name $n]
      lappend pins(byte_rx_gated) [regsub -all {\\} $node_name {\\\\}]
   }
   set pins(byte_rx_gated) [lsort $pins(byte_rx_gated)]

   foreach n $pins(dqs_t) {
      lappend pins(dqsn_nff) [emif_traverse_node_fanout_path $n "dqsn0_0" 10]
   }


}
 
proc emif_initialize_ddr_db { ddr_db_par var_array_name} {
   upvar $ddr_db_par local_ddr_db
   upvar 1 $var_array_name var
 
   global ::GLOBAL_phy_arch_name
   global ::io_only_analysis
 
   post_sdc_message info "Initializing DDR database for CORE $::GLOBAL_phy_arch_name"
   set instance_list [emif_get_core_instance_list $::GLOBAL_phy_arch_name]
 
   foreach instname $instance_list {
 
      for {set io_bank_inst [expr $var(MEM_NUM_IO96)-1]} {$io_bank_inst >= 0} {set io_bank_inst [expr $io_bank_inst-1]} {
      if {$::io_only_analysis == 0}  {
         post_sdc_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_phy_arch_name INSTANCE: $instname BANK:$io_bank_inst"
            emif_get_ddr_pins $instname allpins var $io_bank_inst
         }
 
      set local_ddr_db(${instname}_${io_bank_inst}) [ array get allpins ]
      }
   }
}
 
 
proc emif_get_all_instances_dqs_pins { ddr_db_par } {
   upvar $ddr_db_par local_ddr_db
 
   set dqs_pins [ list ]
   set instnames [ array names local_ddr_db ]
   foreach instance $instnames {
      array set pins $local_ddr_db($instance)
 
      foreach { dqs_pin } $pins(dqs_pins) {
         lappend dqs_pins ${dqs_pin}_IN
         lappend dqs_pins ${dqs_pin}_OUT
      }
      foreach { dqsn_pin } $pins(dqsn_pins) {
         lappend dqs_pins ${dqsn_pin}_OUT
      }
      foreach { ck_pin } $pins(ck_pins) {
         lappend dqs_pins $ck_pin
      }
   }
 
   return $dqs_pins
}
 
proc emif_calculate_counter_value { cnt_hi cnt_lo cnt_bypass } {
   if {$cnt_bypass} {
      set result 1
   } else {
      set result [expr {$cnt_hi + $cnt_lo}]
   }
   return $result
}
 
proc emif_get_input_clk_id { pll_inclk_id var_array_name} {
   upvar 1 $var_array_name var
 
   array set results_array [list]
 
   emif_traverse_fanin_up_to_depth $pll_inclk_id emif_is_node_type_pin clock results_array $var(pll_inclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find PLL clock for [get_node_info -name $pll_inclk_id]"
      set result -1
   }
 
   return $result
}
 
proc emif_get_output_clock_id { pin_list pin_type msg_list_name var_array_name} {
   upvar 1 $msg_list_name msg_list
   upvar 1 $var_array_name var
   set output_clock_id -1
 
   set output_id_list [list]
   set pin_collection [get_keepers -no_duplicates $pin_list]
   if {[get_collection_size $pin_collection] == [llength $pin_list]} {
      foreach_in_collection id $pin_collection {
         lappend output_id_list $id
      }
   } elseif {[get_collection_size $pin_collection] == 0} {
      lappend msg_list "warning" "Could not find any $pin_type pins"
   } else {
      lappend msg_list "warning" "Could not find all $pin_type pins"
   }
   emif_get_pll_clock $output_id_list $pin_type output_clock_id $var(pll_outclock_search_depth)
   return $output_clock_id
}
 
proc emif_get_pll_clock { dest_id_list node_type clock_id_name search_depth} {
   if {$clock_id_name != ""} {
      upvar 1 $clock_id_name clock_id
   }
   set clock_id -1
 
   array set clk_array [list]
   foreach node_id $dest_id_list {
      emif_traverse_fanin_up_to_depth $node_id emif_is_node_type_pll_clk clock clk_array $search_depth
   }
   if {[array size clk_array] == 1} {
      set clock_id [lindex [array names clk_array] 0]
      set clk [get_node_info -name $clock_id]
   } elseif {[array size clk_array] > 1} {
      set clk ""
   } else {
      set clk ""
   }
 
   return $clk
}
 
proc emif_get_vco_clk_id { wf_clock_id var_array_name} {
   upvar 1 $var_array_name var
 
   array set results_array [list]
 
   emif_traverse_fanin_up_to_depth $wf_clock_id emif_is_node_type_vco clock results_array $var(pll_vcoclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find VCO clock for [get_node_info -name $wf_clock_id]"
      set result -1
   }
 
   return $result
}
 
proc emif_is_node_type_pll_clk { node_id } {
   set cell_id [get_node_info -cell $node_id]
 
   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]
 
         if  {[regexp {pll_inst~.*OUTCLK[0-9]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } elseif {$atom_type == "TILE_CTRL"} {
         set node_name [get_node_info -name $node_id]
 
         if {[regexp {tile_ctrl_inst.*\|pa_core_clk_out\[[0-9]\]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}
 
proc emif_is_node_type_vco { node_id } {
   set cell_id [get_node_info -cell $node_id]
 
   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]
 
         if {[regexp {pll_inst.*\|.*vcoph\[0\]$} $node_name]} {
            set result 1
         } elseif {[regexp {pll_inst.*VCOPH0$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}
 
proc emif_does_ref_clk_exist { ref_clk_name } {
 
   set ref_clock_found 0
   foreach_in_collection iclk [get_clocks -nowarn] {
      if { ![is_clock_defined $iclk] } {
         continue
      }
      set clk_targets [get_clock_info -target $iclk]
      foreach_in_collection itgt $clk_targets {
         set node_name [get_node_info -name $itgt]
         if {[string compare $node_name $ref_clk_name] == 0} {
            set ref_clock_found 1
            break
         }
      }
      if {$ref_clock_found == 1} {
         break;
      }
   }
 
   return $ref_clock_found
}
 
 
proc emif_get_cp_current_from_setting { cp_setting } {
 
   set cp_current 0
 
   if {[string compare -nocase $cp_setting "PLL_CP_SETTING0"] == 0} {
      set cp_current 0
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING1"] == 0} {
      set cp_current 5	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING2"] == 0} {
      set cp_current 10
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING3"] == 0} {
      set cp_current 15
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING4"] == 0} {
      set cp_current 20	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING5"] == 0} {
      set cp_current 25		
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING6"] == 0} {
      set cp_current 30
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING7"] == 0} {
      set cp_current 35	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING8"] == 0} {
      set cp_current 40	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING9"] == 0} {
      set cp_current 45
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING10"] == 0} {
      set cp_current 50	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING11"] == 0} {
      set cp_current 55			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING12"] == 0} {
      set cp_current 60
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING13"] == 0} {
      set cp_current 65			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING14"] == 0} {
      set cp_current 70	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING15"] == 0} {
      set cp_current 75			
	} else {
      set cp_current 0
   }
 
   return $cp_current
}
 
proc emif_get_spe_from_cp_current { cp_current } {
 
   set spe 158.0e-12
 
   if {$cp_current <= 15} {
      set spe 158e-012 
   } elseif {$cp_current <= 20} {
      set spe 130.62e-12 
   } elseif {$cp_current <= 25} {
      set spe 117.3e-12 
   } elseif {$cp_current <= 30} {
      set spe 109.5e-12 
   } elseif {$cp_current <= 35} {
      set spe 104.5e-12 
   } elseif {$cp_current <= 40} {
      set spe 100.9e-12 
   } elseif {$cp_current <= 60} {
      set spe 93.3e-12 
   } else {
      set spe 93.3e-12 
   }
   
   return $spe
}
 
proc emif_get_periphery_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var
 
   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      set c2p_setup  0.050
      set c2p_hold   0.0
      set p2c_setup  0.050
      set p2c_hold   0.0
   } else {
      set c2p_setup  0.0
      set c2p_hold   0.0
      set p2c_setup  0.0
      set p2c_hold   0.0
   }
 
   set results [list $c2p_setup $c2p_hold $p2c_setup $p2c_hold]
}
 
proc emif_get_core_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var
 
   set c2c_same_setup  0
   set c2c_same_hold   0
   set c2c_diff_setup  0
   set c2c_diff_hold   0
 
   set results [list $c2c_same_setup $c2c_same_hold $c2c_diff_setup $c2c_diff_hold]
}
 
proc emif_get_core_overconstraints { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var
 
   set results [list $var(C2C_SAME_CLK_SETUP_OC_NS) $var(C2C_SAME_CLK_HOLD_OC_NS) $var(C2C_DIFF_CLK_SETUP_OC_NS) $var(C2C_DIFF_CLK_HOLD_OC_NS)]
}
 
proc emif_get_periphery_overconstraints { results_st_array_name results_mt_array_name var_array_name } {
   upvar 1 $results_st_array_name results_st
   upvar 1 $results_mt_array_name results_mt
   upvar 1 $var_array_name var
 
   set c2p_p2c_frequency [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(C2P_P2C_CLK_RATIO)]
 
   set results_st [list $var(C2P_SETUP_OC_NS) $var(C2P_HOLD_OC_NS) $var(P2C_SETUP_OC_NS) $var(P2C_HOLD_OC_NS)]
   set results_mt [list [expr $var(C2P_SETUP_OC_NS) + 0.000] [expr $var(C2P_HOLD_OC_NS) + 0.000] [expr $var(P2C_SETUP_OC_NS) + 0.000] [expr $var(P2C_HOLD_OC_NS) + 0.000]]
 
}
 
 
proc emif_sort_duplicate_names { names_array } {
 
   set main_name ""
   set duplicate_names [list]
 
   # Find the main name as opposed to all the duplicate names
   foreach { name } $names_array {
      if  {[regexp {Duplicate} $name]} {
         lappend duplicate_names $name
      } else {
         if {$main_name == ""} {
            set main_name $name
         } else {
            post_message -type error "More than one main tile name ($main_name and $name).  Please verify the connectivity of these pins."
         }
      }
   }
 
   # Now sort the duplicate names
   set duplicate_names [lsort -decreasing $duplicate_names]
 
   # Prepend the main name and then return
   set result [join [linsert $duplicate_names 0 $main_name]]
 
   return $result
}
 

 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 28 ed_synth_emif_io96b_lpddr4_0 21 emif_io96b_lpddr4_200 5 synth 75 ed_synth_emif_io96b_lpddr4_0_emif_io96b_lpddr4_200_hyctmiq_timing_utils.tcl 19150 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.



set script_dir [file dirname [info script]]

load_package sdc_ext
load_package design

proc emif_index_in_collection { col j } {
   set i 0
   foreach_in_collection path $col {
      if {$i == $j} {
         return $path
      }
      set i [expr $i + 1]
   }
   return ""
}


proc emif_get_clock_to_pin_name_mapping {} {
   set result [list]
   set clocks_collection [get_clocks]
   foreach_in_collection clock $clocks_collection {
      if { ![is_clock_defined $clock] } {
         continue
      }
      set clock_name [get_clock_info -name $clock]
      set clock_target [get_clock_info -targets $clock]
      set first_index [emif_index_in_collection $clock_target 0]
      set catch_exception_net [catch {get_net_info -name $first_index} pin_name_net]
      if {$catch_exception_net == 0} {
         lappend result [list $clock_name $pin_name_net]
      } else {
         set catch_exception_port [catch {get_port_info -name $first_index} pin_name_port]
         if {$catch_exception_port == 0} {
            lappend result [list $clock_name $pin_name_port]
         } else {
            set catch_exception_reg [catch {get_register_info -name $first_index} pin_name_reg]
            if {$catch_exception_reg == 0} {
               lappend result [list $clock_name $pin_name_reg]
            } else {
               set catch_exception_pin [catch {get_pin_info -name $first_index} pin_name_pin]
               if {$catch_exception_pin == 0} {
                  lappend result [list $clock_name $pin_name_pin]
               }
            }
         }
      }
   }
   return $result
}


proc emif_get_clock_name_from_pin_name { pin_name } {
   set table [emif_get_clock_to_pin_name_mapping]
   foreach entry $table {
      if {[string compare [lindex [lindex [split $entry] 1] 0] $pin_name] == 0} {
         return [lindex $entry 0]
      }
   }
   return ""
}



proc emif_find_all_keepers { mystring } {
   set allkeepers [get_keepers $mystring ]

   foreach_in_collection keeper $allkeepers {
      set keepername [ get_node_info -name $keeper ]

      puts "$keepername"
   }
}

proc emif_round_3dp { x } {
   return [expr { round($x * 1000) / 1000.0  } ]
}

proc emif_get_current_timequest_report_folder {} {

   set catch_exception [catch {get_current_timequest_report_folder} error_message]
   if {[regexp ERROR $error_message] == 1} {
      return "ReportDDR"
   } else {
      return [get_current_timequest_report_folder]
   }
}
proc emif_are_entity_names_on { } {
   return [set_project_mode -is_show_entity]
}

proc emif_get_core_instance_list {corename} {
   global ::io_only_analysis

   if {$::io_only_analysis == 1}  {
      set instance_list [list $corename]

   } else {
      set full_instance_list [emif_get_core_full_instance_list $corename]
      set instance_list [list]

      foreach inst $full_instance_list {
         set sta_name $inst
         if {[lsearch $instance_list [escape_brackets $sta_name]] == -1} {
            lappend instance_list $sta_name
         }
      }

   }
   return $instance_list
}

proc emif_get_or_add_generated_clock {args} {
   array set opts [list -name "" -target "" -source "" -multiply_by 1 -divide_by 1 -phase 0]
   array set opts $args

   set multiply_by [expr int($opts(-multiply_by))]
   if {[expr $multiply_by - $opts(-multiply_by)] != 0.0} {
      post_message -type error "Specify an integer ranging from 0 to 99999999 for the option -multiply_by"
      return ""
   }

   set clock_name [emif_get_clock_name_from_pin_name $opts(-target)]

   if {[string compare -nocase $clock_name ""] == 0} {
      set nets [get_nets $opts(-target) -nowarn]
      if {[get_collection_size $nets] > 0} {
         set pin_name [get_pin_info -name [get_net_info -pin $nets]]
         set clock_name [emif_get_clock_name_from_pin_name $pin_name]

         if {[string compare -nocase $clock_name ""] != 0} {
            if {[regexp -nocase "lvds_clk" $pin_name] || [regexp -nocase "loaden" $pin_name] } {
               remove_clock $clock_name
               set clock_name ""
            }
          }
       }
   } else {
      if {([string compare -nocase $opts(-name) ""] != 0) && ([string compare -nocase $opts(-name) $clock_name])} {

         if {[regexp -nocase "pll_inst\|outclk" $opts(-target)]} {
            remove_clock $clock_name
            set clock_name ""
         }
      }
   }

   if {[string compare -nocase $clock_name ""] == 0} {
      set clock_name $opts(-name)

      create_generated_clock \
         -name $clock_name \
         -source $opts(-source) \
         -multiply_by $multiply_by \
         -divide_by $opts(-divide_by) \
         -phase $opts(-phase) \
         $opts(-target)
   }

   return $clock_name
}

proc emif_get_core_full_instance_list {corename} {

   set instance_list [list]

   if {[is_fitter_in_qhd_mode]} {
      set instance_list_pre [design::get_instances -entity $corename]

   } else {
      set instance_list_pre [get_entity_instances $corename]
   }

   foreach instance $instance_list_pre {
      regsub {\|arch$} $instance "" instance_no_arch
      lappend instance_list $instance_no_arch
   }

   if {[ llength $instance_list ] == 0} {
      post_message -type error "The auto-constraining script was not able to detect any instance for core < $corename >"
      post_message -type error "Make sure the core < $corename > is instantiated within another component (wrapper)"
      post_message -type error "and it's not the top-level for your project"
   }

   return $instance_list
}


proc emif_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
   upvar 1 $results_array_name results

   if {$depth < 0} {
      error "Internal error: Bad timing netlist search depth"
   }
   set fanin_edges [get_node_info -${edge_type}_edges $node_id]
   set number_of_fanin_edges [llength $fanin_edges]
   for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
      set fanin_edge [lindex $fanin_edges $i]
      set fanin_id [get_edge_info -src $fanin_edge]
      if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
         set results($fanin_id) 1
      } elseif {$depth == 0} {
      } else {
         emif_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
      }
   }
}

proc emif_is_node_type_pin { node_id } {
   set node_type [get_node_info -type $node_id]
   if {$node_type == "port"} {
      set result 1
   } else {
      set result 0
   }
   return $result
}

proc emif_is_node_type_reg {node_id } {
   set node_type [get_node_info -type $node_id]
   if {$node_type == "reg"} {
      set result 1
   } else {
      set result 0
   }
   return $result
}
proc emif_get_pll_clock_name { clock_id } {
   set clock_name [get_node_info -name $clock_id]

   return $clock_name
}

proc post_sdc_message {msg_type msg} {
   global ::io_only_analysis

   if {($::io_only_analysis == 1) || $::TimeQuestInfo(nameofexecutable) != "quartus_fit"} {
      post_message -type $msg_type $msg
   }
}

proc emif_get_names_in_collection { col } {
   set res [list]
   foreach_in_collection node $col {
      lappend res [ get_node_info -name $node ]
   }
   return $res
}

proc emif_format_3dp { x } {
   return [format %.3f $x]
}

proc emif_get_colours { x y } {

   set fcolour [list "black"]
   if {$x < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }
   if {$y < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }

   return $fcolour
}

proc min { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a < $b } {
      return $a
   } else {
      return $b
   }
}

proc max { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a > $b } {
      return $a
   } else {
      return $b
   }
}

proc emif_max_in_collection { col attribute } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set max [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp > $max} {
            set max $temp
         }
      }
      set i [expr $i + 1]
   }
   return $max
}

proc emif_min_in_collection { col attribute } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set min [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp < $min} {
            set min $temp
         }
      }
      set i [expr $i + 1]
   }
   return $min
}

proc emif_min_in_collection_to_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -to_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_min_in_collection_from_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -from_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_min_in_collection_to_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_min_in_collection_from_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_max_in_collection_to_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_max_in_collection_from_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}


proc emif_min_in_collection_to_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_min_in_collection_from_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_max_in_collection_to_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_max_in_collection_from_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_sort_proc {a b} {
   set idxs [list 1 2 0]
   foreach i $idxs {
      set ai [lindex $a $i]
      set bi [lindex $b $i]
      if {$ai > $bi} {
         return 1
      } elseif { $ai < $bi } {
         return -1
      }
   }
   return 0
}

proc emif_gcd {p q} {
   set p [expr {abs($p)}]
   set q [expr {abs($q)}]
   while {$q != 0} {
      set r [expr {$p % $q}]
      set p $q
      set q $r
   }
   return $p
}

proc emif_traverse_node_fanout_path {src_node dst_filter max_depth} {
   set result [list]
   if {$max_depth == 0} { return $result }
   set edgenodes [get_node_info -fanout_edges $src_node]
   foreach e $edgenodes {
      set nodename [get_node_info -name [get_edge_info -dst $e]]
      if {[regexp $dst_filter $nodename]} {
         lappend result $nodename
      } else {
         set rresult [emif_traverse_node_fanout_path $nodename $dst_filter [expr $max_depth -1]]
         set result [list {*}$result {*}$rresult]
      }
   }

   return [lsort -unique $result]
}

proc emif_traverse_atom_path {atom_id atom_oport_id path} {
   # Return list of {atom oterm_id} pairs by tracing the atom netlist starting from the given atom_id through the given path
   # Path consists of list of {atom_type fanin|fanout|end <port_type> <-optional>}
   set result [list]
   if {[llength $path] > 0} {
      set path_point [lindex $path 0]
      set atom_type [lindex $path_point 0]
      set next_direction [lindex $path_point 1]
      set port_type [lindex $path_point 2]
      set atom_optional [lindex $path_point 3]
      if {[get_atom_node_info -key type -node $atom_id] == $atom_type} {
         if {$next_direction == "end"} {
            if {[get_atom_port_info -key type -node $atom_id -port_id $atom_oport_id -type oport] == $port_type} {
               lappend result [list $atom_id $atom_oport_id]
            }
         } elseif {$next_direction == "atom"} {
            lappend result [list $atom_id]
         } elseif {$next_direction == "fanin"} {
            set atom_iport [get_atom_iport_by_type -node $atom_id -type $port_type]
            if {$atom_iport != -1} {
               set iport_fanin [get_atom_port_info -key fanin -node $atom_id -port_id $atom_iport -type iport]
               set source_atom [lindex $iport_fanin 0]
               set source_oterm [lindex $iport_fanin 1]
               set result [emif_traverse_atom_path $source_atom $source_oterm [lrange $path 1 end]]
            } elseif {$atom_optional == "-optional"} {
               set result [emif_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
            }
         } elseif {$next_direction == "fanout"} {
            set atom_oport [get_atom_oport_by_type -node $atom_id -type $port_type]
            if {$atom_oport != -1} {
               set oport_fanout [get_atom_port_info -key fanout -node $atom_id -port_id $atom_oport -type oport]
               foreach dest $oport_fanout {
                  set dest_atom [lindex $dest 0]
                  set dest_iterm [lindex $dest 1]
                  set fanout_result_list [emif_traverse_atom_path $dest_atom -1 [lrange $path 1 end]]
                  foreach fanout_result $fanout_result_list {
                     if {[lsearch $result $fanout_result] == -1} {
                        lappend result $fanout_result
                     }
                  }
               }
            }
         } else {
            error "Unexpected path"
         }
      } elseif {$atom_optional == "-optional"} {
         set result [emif_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
      }
   }
   return $result
}

proc emif_get_operating_conditions_number {} {
   set cur_operating_condition [get_operating_conditions]
   set counter 0
   foreach_in_collection op [get_available_operating_conditions] {
      if {[string compare $cur_operating_condition $op] == 0} {
         return $counter
      }
      incr counter
   }
   return $counter
}

proc emif_add_false_path {sta_on path_delay args} {
     set min_path_delay [expr (-1*${path_delay})]
     if ${sta_on} {
     	set_false_path {*}$args
     } else {
     	set_max_delay ${path_delay} {*}$args
     	set_min_delay ${min_path_delay} {*}$args
     }
}

 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 22 ed_synth_reset_handler 21 mem_reset_handler_100 5 synth 21 mem_reset_handler.sdc 2996 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#__ACDS_USER_COMMENT__####################################################################
#__ACDS_USER_COMMENT__
#__ACDS_USER_COMMENT__ THIS IS AN AUTO-GENERATED FILE!
#__ACDS_USER_COMMENT__ -------------------------------
#__ACDS_USER_COMMENT__ If you modify this files, all your changes will be lost if you
#__ACDS_USER_COMMENT__ regenerate the core!
#__ACDS_USER_COMMENT__
#__ACDS_USER_COMMENT__ FILE DESCRIPTION
#__ACDS_USER_COMMENT__ ----------------
#__ACDS_USER_COMMENT__ This file specifies the timing constraints for the EMIF local_reset_combiner
#__ACDS_USER_COMMENT__ component, which is instantiated as part of the EMIF example design.

set ::syn_flow 0
set ::sta_flow 0
set ::fit_flow 0
set ::pow_flow 0

if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
    set ::syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
    set ::sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
    set ::fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
    set ::pow_flow 1
}

proc apply_sdc_reset_synchronizer {hier_path} {
    global ::fit_flow

    set tmp_pin [get_pins -nowarn ${hier_path}|clrn]
    if {[get_collection_size $tmp_pin] > 0} {
        if {$::fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $hier_path -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $hier_path -hold 6 -end
        } else {
            set_false_path -through $tmp_pin -to $hier_path
        }
    }
}

proc apply_sdc_data_synchronizer_input {hier_path} {
    global ::fit_flow

    set tmp_pin [get_pins -nowarn ${hier_path}|d]
    if {[get_collection_size $tmp_pin] > 0} {
        if {$::fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $hier_path -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $hier_path -hold 6 -end
        } else {
            set_false_path -through $tmp_pin -to [get_keepers $hier_path]
        }
    }
}

#apply_sdc_reset_synchronizer "*mem_reset_handler_inst*reset_sync_inst|din_s1"
apply_sdc_data_synchronizer_input "mem_reset_handler_inst|reset_n_sync.reset_sync_inst|din_s1"

 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 13 ed_synth_rrip 32 altera_s10_user_rst_clkgate_1947 5 synth 34 altera_s10_user_rst_clkgate_fm.sdc 1750 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#Create base clock with 100 MHz targetted for internal clocks if paths listed below found in the design

#Agilex
#auto_fab_0|alt_sld_fab_0|alt_sld_fab_0|agilexconfigreset|user_reset|sdm_gpo_out_user_reset~internal_ctrl_clock.reg


set intrl_ctrl_reg_count 0

set intrl_ctrl_reg_collection [get_registers -nowarn "auto_fab*\|*\|*sdm_gpo_out_user_reset~internal_ctrl_clock.reg"]

set intrl_ctrl_reg_count [ get_collection_size $intrl_ctrl_reg_collection ]



if {$intrl_ctrl_reg_count > 0 && ![get_collection_size [get_clocks -nowarn {internal_clk}]]} {

	create_clock -name internal_clk -period 10.000 -waveform {0.000 5.000} { auto_fab*|*|*sdm_gpo_out_user_reset~internal_ctrl_clock.reg }

	set_clock_groups -asynchronous -group [get_clocks {internal_clk}]
	
	set intrl_clock_count [get_collection_size [get_clocks internal_clk]]

	post_message -type info "clock = [get_clocks {internal_clk}]"
	
	post_message -type info "number of internal_clk created = $intrl_clock_count"

}
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 26 ed_synth_traffic_generator 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 26 ed_synth_traffic_generator 28 altera_reset_controller_1924 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 26 ed_synth_traffic_generator 25 hydra_driver_mem_axi4_100 5 synth 25 hydra_driver_mem_axi4.sdc 3836 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains timing constraints for Test Engine's Memory AXI4 Driver

set ::syn_flow 0
set ::sta_flow 0
set ::fit_flow 0
set ::pow_flow 0

if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
    set ::syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
    set ::sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
    set ::fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
    set ::pow_flow 1
}

proc apply_sdc_reset_synchronizer {hier_path} {
    global ::fit_flow

    set tmp_keep [get_keepers -nowarn $hier_path]
    set tmp_pin [get_pins -nowarn ${hier_path}|clrn]
    if {[get_collection_size $tmp_pin] > 0} {
        if {$::fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp_keep -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp_keep -hold 6 -end
        } else {
            set_false_path -through $tmp_pin -to $tmp_keep
        }
    }
}

proc apply_sdc_data_synchronizer {hier_path} {
    global ::fit_flow

    set tmp_keep [get_keepers -nowarn $hier_path]
    set tmp_pin [get_pins -nowarn [list "${hier_path}|d" "${hier_path}|*data"]]
    if {[get_collection_size $tmp_pin] > 0} {
        if {$::fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp_keep -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp_keep -hold 6 -end
        } else {
            set_false_path -through $tmp_pin -to $tmp_keep
        }
    }
}


apply_sdc_data_synchronizer "reset_tree|sync|din_s1"
apply_sdc_data_synchronizer "csr_reset_tree|sync|din_s1"

set from_regs [get_registers -nowarn "csr_reset_tree|reset_leaf*"]
set to_regs   [get_registers -nowarn "csr_bank|*_skidbuf|skid.showahead_fifo|empty"]
if {[get_collection_size $from_regs] > 0 && [get_collection_size $to_regs] > 0} {
    set_false_path -from $from_regs -to $to_regs
}

set from_regs [get_registers -nowarn "csr_reset_tree|reset_leaf*"]
set to_regs   [get_registers -nowarn "csr_bank|*_skidbuf|skid.showahead_fifo|dc.dcfifo_inst|a*|*"]
if {[get_collection_size $from_regs] > 0 && [get_collection_size $to_regs] > 0} {
    set_false_path -from $from_regs -to $to_regs
}

set from_keep [get_keepers -nowarn "*_skidbuf|skid.showahead_fifo|dc.dcfifo_inst*ff_launch[*]"]
set to_keep   [get_keepers -nowarn "*_skidbuf|skid.showahead_fifo|dc.dcfifo_inst*ff_meta[*]"]
if {[get_collection_size $from_keep] > 0 && [get_collection_size $to_keep] > 0} {
    if {$::fit_flow == 1} {
        set_multicycle_path -from $from_keep -to $to_keep -setup 2 -end
        set_multicycle_path -from $from_keep -to $to_keep -hold 1 -end
    } else {
        set_false_path -from $from_keep -to $to_keep
    }
}
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 26 ed_synth_traffic_generator 20 hydra_global_csr_100 5 synth 20 hydra_global_csr.sdc 3432 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains timing constraints for Test Engine's Global CSR

set ::syn_flow 0
set ::sta_flow 0
set ::fit_flow 0
set ::pow_flow 0

if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
    set ::syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
    set ::sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
    set ::fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
    set ::pow_flow 1
}

proc apply_sdc_reset_synchronizer {hier_path} {
    # Relax timing for the async reset signal going into the synchronizers
    # See RTL for the justification of setup=7 and hold=6
    global ::fit_flow

    set tmp_keep [get_keepers -nowarn $hier_path]
    set tmp_pin [get_pins -nowarn ${hier_path}|clrn]
    if {[get_collection_size $tmp_pin] > 0} {
        if {$::fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp_keep -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp_keep -hold 6 -end
        } else {
            set_false_path -through $tmp_pin -to $tmp_keep
        }
    }
}

proc apply_sdc_data_synchronizer {hier_path} {
    # Relax timing for signal going into the synchronizers
    # setup=7 and hold=6 are somewhat arbitrary choices
    global ::fit_flow

    set tmp_keep [get_keepers -nowarn $hier_path]
    set tmp_pin [get_pins -nowarn [list "${hier_path}|d" "${hier_path}|*data"]]
    if {[get_collection_size $tmp_pin] > 0} {
        if {$::fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp_keep -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp_keep -hold 6 -end
        } else {
            set_false_path -through $tmp_pin -to $tmp_keep
        }
    }
}

# Timing constraints for global signal synchronizers
foreach sync [list "global_csr_sync|g2d[*].run_sync" \
                   "global_csr_sync|g2d[*].done_sync" \
                   "global_csr_sync|g2d[*].error_sync" \
                   \
                   "global_csr_sync|d2d[*].post_in[*].sync" \
                   "global_csr_sync|d2d[*].wait_in[*].sync" \
    ] {

    apply_sdc_reset_synchronizer "${sync}|*"
    apply_sdc_data_synchronizer "${sync}|din_s1"
}

# Timing constraints for reset signal synchronizer
apply_sdc_data_synchronizer "reset_tree|sync|*"
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 17 ed_synth_user_pll 17 altera_iopll_2000 5 synth 47 ed_synth_user_pll_altera_iopll_2000_q2hxwiy.sdc 10080 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the timing constraints for the Altera PLL.
#    * The helper routines are defined in ed_synth_user_pll_altera_iopll_2000_q2hxwiy_pin_map.tcl
#
# NOTE
# ----
# Debug switch. Change to 1 to get more run-time debug information
set debug 0

set script_dir [file dirname [info script]]

source "$script_dir/ed_synth_user_pll_altera_iopll_2000_q2hxwiy_parameters.tcl"
source "$script_dir/ed_synth_user_pll_altera_iopll_2000_q2hxwiy_pin_map.tcl"
source "$script_dir/ed_synth_user_pll_altera_iopll_2000_q2hxwiy_all_ip_params.tcl"

####################
#                  #
# GENERAL SETTINGS #
#                  #
####################

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty


# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ ai_are_entity_names_on ]

if {[catch {load_package atoms
            load_package sdc_ext
            load_package design
            catch {read_atom_netlist} read_atom_netlist_out
            set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]
            } err_loading_packages]} {
    post_message -type error "Failed to load packages required by IOPLL SDC: $err_loading_packages"
}

# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to apply timing constraints.
# During the fitter, the routines will be called only once
# and cached data will be used in all subsequent calls.



if {[info exists ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_ai_pll_db]} {
    # Clean-up stale content
    unset ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_ai_pll_db
}
if {[catch {ai_initialize_pll_db ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_ai_pll_db} err_initializing_db]} {
    post_message -type warning "Failed to find atom information in IOPLL SDC: $err_initializing_db"
}

# If multiple instances of this core are present in the
# design they will all be constrained through the
# following loop
set instances [ array names ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_ai_pll_db ]
foreach { inst } $instances {
    if { [ info exists pins ] } {
        # Clean-up stale content
        unset pins
    }
    
    # -------------------------------- #
    # -                              - #
    # --- Determine PLL Parameters --- #
    # -                              - #
    # -------------------------------- #
    
    set pll_atoms [get_atom_nodes -matching ${inst}* -type IOPLL]
    set num_pll_inst [get_collection_size $pll_atoms]
    
    if {$num_pll_inst > 1} { 
        # Error condition
        post_message -type error "SDC: More than one PLL atom found with instance name $inst"
    } else {
        # Use IP generated parameters
        if { $debug } {
            post_message -type info "SDC: using IP generated parameter values"
        }
    }

    # These dictionaries hold all the clock information.
    lassign $::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_ai_pll_db($inst) base_clock_data_dict gen_clock_data_dict
    
    # ------------------------ #
    # -                      - #
    # ---REFERENCE CLOCK(s)--- #
    # -                      - #
    # ------------------------ #
    dict for {clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_fpga_pin && !$exists} {
               create_clock -period $period \
                   -waveform [ list 0 $half_period] \
                   -name $name $port_node_name \
                   -add
            }
        }
    }
    # ------------------------- #
    # -                       - #
    # --- OUTPUT PLL CLOCKS --- #
    # -                       - #
    # ------------------------- #
    set refclk_iterm_dict [dict create]
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            if {[is_post_syn_sta]} {
                if {$is_valid && !$exists} {
                    create_non_virtual_generated_clock_with_master_or_source \
                        $master \
                        $src \
                        $name \
                        $multiply_by \
                        $divide_by \
                        $phase \
                        $duty_cycle \
                        $pin_node_name

                    if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {
                        set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                    }
                } elseif {[is_m_n_cntr $pattern]} {
                    create_virtual_generated_clock_with_master_or_source \
                        $master \
                        $src \
                        $name \
                        $multiply_by \
                        $divide_by \
                        $phase \
                        $duty_cycle
                }
            } else {
                if {$is_valid && !$exists} {
                    
                    unset -nocomplain refclk_hier
                    regexp -- {^(.*tennm_ph2_iopll)} $pin_node_name -> refclk_hier
                    if {[info exists refclk_hier] == 0} {
                       regexp -- {^(.*intelsixteen_iopll)} $pin_node_name -> refclk_hier
                    }
               
                    set refclk_src "${refclk_hier}|ref_clk0"
                    set master_clock [get_master_clock_given_refclk_src $refclk_src]
                    set need_master_clock_set false
					
                    # Case: 15014500070, not creating the intermediate clock when the current pll is a downstream cascading pll.
                    set pll_ip_params $::pll_all_ip_params
                    set is_downstream_cascading_clk [expr {[dict get $pll_ip_params gui_enable_permit_cal] || [dict get $pll_ip_params gui_enable_cascade_in]}]
                    if {!$is_downstream_cascading_clk} {
                        if {$src eq $refclk_src} {
                            # Intermediate clock already exists but doesn't have master clock set.
                            # Can't set master clock on existing intermediate clock without warnings so need to set master clock on current clock.
                            set need_master_clock_set [expr {$master ne ""}]
                            dict set refclk_iterm_dict $refclk_src $src
                        } elseif {![dict exists $refclk_iterm_dict $refclk_src]} {
                            create_generated_clock -add \
                                -source $src \
                                -master_clock $master_clock \
                                $refclk_src
                            dict set refclk_iterm_dict $refclk_src $src
                        }
                        if {[dict exists $refclk_iterm_dict $refclk_src] && $src eq [dict get $refclk_iterm_dict $refclk_src]} {
                            set src $refclk_src
                        }
                    }

                    if {$need_master_clock_set} {
				  
                        create_generated_clock -add \
                            -source $src \
                            -master_clock $master_clock\
                            -name $name \
                            -multiply_by $multiply_by \
                            -divide_by $divide_by \
                            -phase $phase \
                            -duty_cycle $duty_cycle \
                            $pin_node_name
                    } else {
				  
                        create_generated_clock -add \
                            -source $src \
                            -name $name \
                            -multiply_by $multiply_by \
                            -divide_by $divide_by \
                            -phase $phase \
                            -duty_cycle $duty_cycle \
                            $pin_node_name
                    }
                    
                    if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {
                        set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                    }
                }
            }
        }
    }

    foreach_in_collection node [get_nodes -no_duplicates -nowarn "${inst}|tennm_ph2_iopll|reset"] {
        set_false_path -through [get_node_info -name $node]
    }
}
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 17 ed_synth_user_pll 17 altera_iopll_2000 5 synth 61 ed_synth_user_pll_altera_iopll_2000_q2hxwiy_all_ip_params.tcl 51826 # PLL parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!

set ::pll_corename ed_synth_user_pll_altera_iopll_2000_q2hxwiy

set ::pll_all_ip_params [dict create]

dict set ::pll_all_ip_params gui_device_family "Agilex 5"
dict set ::pll_all_ip_params gui_device_component "A5ED065BB32AE6SR0"
dict set ::pll_all_ip_params gui_device_speed_grade "6"
dict set ::pll_all_ip_params gui_device_iobank_rev "IO96B"
dict set ::pll_all_ip_params gui_debug_mode "false"
dict set ::pll_all_ip_params gui_skip_sdc_generation "false"
dict set ::pll_all_ip_params gui_include_iossm "false"
dict set ::pll_all_ip_params gui_cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params gui_parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params gui_pll_tclk_mux_en "false"
dict set ::pll_all_ip_params gui_pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params gui_pll_freqcal_en "true"
dict set ::pll_all_ip_params gui_pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params gui_cal_converge "false"
dict set ::pll_all_ip_params gui_cal_error "cal_clean"
dict set ::pll_all_ip_params gui_pll_cal_done "false"
dict set ::pll_all_ip_params gui_pll_type "S10_Physical"
dict set ::pll_all_ip_params gui_pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params system_info_device_family "Agilex 5"
dict set ::pll_all_ip_params system_info_device_component "A5ED065BB32AE6SR0"
dict set ::pll_all_ip_params system_info_device_speed_grade "6"
dict set ::pll_all_ip_params system_part_trait_speed_grade "6"
dict set ::pll_all_ip_params system_part_trait_iobank_rev "IO96B"
dict set ::pll_all_ip_params gui_usr_device_speed_grade "1"
dict set ::pll_all_ip_params gui_en_reconf "false"
dict set ::pll_all_ip_params gui_en_hvio_reconf "false"
dict set ::pll_all_ip_params gui_en_iossm_reconf "false"
dict set ::pll_all_ip_params gui_user_base_address "0"
dict set ::pll_all_ip_params gui_en_dps_ports "false"
dict set ::pll_all_ip_params gui_pll_mode "Integer-N PLL"
dict set ::pll_all_ip_params gui_location_type "Fabric-Feeding"
dict set ::pll_all_ip_params gui_use_logical "false"
dict set ::pll_all_ip_params gui_reference_clock_frequency "100.0"
dict set ::pll_all_ip_params gui_reference_clock_frequency_ps "10000.0"
dict set ::pll_all_ip_params gui_use_coreclk "true"
dict set ::pll_all_ip_params gui_refclk_might_change "false"
dict set ::pll_all_ip_params gui_fractional_cout "32"
dict set ::pll_all_ip_params gui_prot_mode "UNUSED"
dict set ::pll_all_ip_params gui_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params gui_use_locked "true"
dict set ::pll_all_ip_params gui_en_adv_params "false"
dict set ::pll_all_ip_params gui_pll_bandwidth_preset "Medium"
dict set ::pll_all_ip_params gui_lock_setting "Low Lock Time"
dict set ::pll_all_ip_params gui_pll_auto_reset "false"
dict set ::pll_all_ip_params gui_en_lvds_ports "Disabled"
dict set ::pll_all_ip_params gui_en_periphery_ports "false"
dict set ::pll_all_ip_params gui_operation_mode "direct"
dict set ::pll_all_ip_params gui_feedback_clock "Global Clock"
dict set ::pll_all_ip_params gui_clock_to_compensate "0"
dict set ::pll_all_ip_params gui_use_NDFB_modes "false"
dict set ::pll_all_ip_params gui_refclk_switch "false"
dict set ::pll_all_ip_params gui_refclk1_frequency "100.0"
dict set ::pll_all_ip_params gui_en_phout_ports "false"
dict set ::pll_all_ip_params gui_phout_division "1"
dict set ::pll_all_ip_params gui_en_extclkout_ports "false"
dict set ::pll_all_ip_params gui_number_of_clocks "2"
dict set ::pll_all_ip_params gui_multiply_factor "6"
dict set ::pll_all_ip_params gui_divide_factor_n "1"
dict set ::pll_all_ip_params gui_frac_multiply_factor "1"
dict set ::pll_all_ip_params gui_fix_vco_frequency "false"
dict set ::pll_all_ip_params gui_fixed_vco_frequency "600.0"
dict set ::pll_all_ip_params gui_fixed_vco_frequency_ps "1667.0"
dict set ::pll_all_ip_params gui_vco_frequency "600.0"
dict set ::pll_all_ip_params gui_enable_output_counter_cascading "false"
dict set ::pll_all_ip_params gui_mif_gen_options "Generate New MIF File"
dict set ::pll_all_ip_params gui_new_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_existing_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_mif_config_name "unnamed"
dict set ::pll_all_ip_params gui_active_clk "false"
dict set ::pll_all_ip_params gui_clk_bad "false"
dict set ::pll_all_ip_params gui_switchover_mode "Automatic Switchover"
dict set ::pll_all_ip_params gui_switchover_delay "0"
dict set ::pll_all_ip_params gui_enable_cascade_out "false"
dict set ::pll_all_ip_params gui_cascade_outclk_index "0"
dict set ::pll_all_ip_params gui_enable_cascade_in "false"
dict set ::pll_all_ip_params gui_enable_permit_cal "false"
dict set ::pll_all_ip_params gui_enable_upstream_out_clk "false"
dict set ::pll_all_ip_params gui_pll_cascading_mode "adjpllin"
dict set ::pll_all_ip_params gui_enable_mif_dps "false"
dict set ::pll_all_ip_params gui_dps_cntr "C0"
dict set ::pll_all_ip_params gui_dps_num "1"
dict set ::pll_all_ip_params gui_dps_dir "Positive"
dict set ::pll_all_ip_params gui_extclkout_0_source "C0"
dict set ::pll_all_ip_params gui_extclkout_1_source "C0"
dict set ::pll_all_ip_params gui_extclkout_source "C0"
dict set ::pll_all_ip_params gui_clock_name_global "false"
dict set ::pll_all_ip_params gui_clock_name_instantiation "false"
dict set ::pll_all_ip_params gui_clock_name_string0 "outclk0"
dict set ::pll_all_ip_params gui_clock_name_string1 "outclk1"
dict set ::pll_all_ip_params gui_clock_name_string2 "outclk2"
dict set ::pll_all_ip_params gui_clock_name_string3 "outclk3"
dict set ::pll_all_ip_params gui_clock_name_string4 "outclk4"
dict set ::pll_all_ip_params gui_clock_name_string5 "outclk5"
dict set ::pll_all_ip_params gui_clock_name_string6 "outclk6"
dict set ::pll_all_ip_params gui_clock_name_string7 "outclk7"
dict set ::pll_all_ip_params gui_clock_name_string8 "outclk8"
dict set ::pll_all_ip_params gui_clock_name_string9 "outclk9"
dict set ::pll_all_ip_params gui_clock_name_string10 "outclk10"
dict set ::pll_all_ip_params gui_clock_name_string11 "outclk11"
dict set ::pll_all_ip_params gui_clock_name_string12 "outclk12"
dict set ::pll_all_ip_params gui_clock_name_string13 "outclk13"
dict set ::pll_all_ip_params gui_clock_name_string14 "outclk14"
dict set ::pll_all_ip_params gui_clock_name_string15 "outclk15"
dict set ::pll_all_ip_params gui_clock_name_string16 "outclk16"
dict set ::pll_all_ip_params gui_clock_name_string17 "outclk17"
dict set ::pll_all_ip_params gui_divide_factor_c0 "6"
dict set ::pll_all_ip_params gui_divide_factor_c1 "6"
dict set ::pll_all_ip_params gui_divide_factor_c2 "6"
dict set ::pll_all_ip_params gui_divide_factor_c3 "6"
dict set ::pll_all_ip_params gui_divide_factor_c4 "6"
dict set ::pll_all_ip_params gui_divide_factor_c5 "6"
dict set ::pll_all_ip_params gui_divide_factor_c6 "6"
dict set ::pll_all_ip_params gui_divide_factor_c7 "6"
dict set ::pll_all_ip_params gui_divide_factor_c8 "6"
dict set ::pll_all_ip_params gui_divide_factor_c9 "6"
dict set ::pll_all_ip_params gui_divide_factor_c10 "6"
dict set ::pll_all_ip_params gui_divide_factor_c11 "6"
dict set ::pll_all_ip_params gui_divide_factor_c12 "6"
dict set ::pll_all_ip_params gui_divide_factor_c13 "6"
dict set ::pll_all_ip_params gui_divide_factor_c14 "6"
dict set ::pll_all_ip_params gui_divide_factor_c15 "6"
dict set ::pll_all_ip_params gui_divide_factor_c16 "6"
dict set ::pll_all_ip_params gui_divide_factor_c17 "6"
dict set ::pll_all_ip_params gui_cascade_counter0 "false"
dict set ::pll_all_ip_params gui_cascade_counter1 "false"
dict set ::pll_all_ip_params gui_cascade_counter2 "false"
dict set ::pll_all_ip_params gui_cascade_counter3 "false"
dict set ::pll_all_ip_params gui_cascade_counter4 "false"
dict set ::pll_all_ip_params gui_cascade_counter5 "false"
dict set ::pll_all_ip_params gui_cascade_counter6 "false"
dict set ::pll_all_ip_params gui_cascade_counter7 "false"
dict set ::pll_all_ip_params gui_cascade_counter8 "false"
dict set ::pll_all_ip_params gui_cascade_counter9 "false"
dict set ::pll_all_ip_params gui_cascade_counter10 "false"
dict set ::pll_all_ip_params gui_cascade_counter11 "false"
dict set ::pll_all_ip_params gui_cascade_counter12 "false"
dict set ::pll_all_ip_params gui_cascade_counter13 "false"
dict set ::pll_all_ip_params gui_cascade_counter14 "false"
dict set ::pll_all_ip_params gui_cascade_counter15 "false"
dict set ::pll_all_ip_params gui_cascade_counter16 "false"
dict set ::pll_all_ip_params gui_cascade_counter17 "false"
dict set ::pll_all_ip_params gui_output_clock_frequency0 "220.0"
dict set ::pll_all_ip_params gui_output_clock_frequency1 "110.0"
dict set ::pll_all_ip_params gui_output_clock_frequency2 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency3 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency4 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps0 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps1 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps2 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps3 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps4 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps5 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps6 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps7 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps8 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps9 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps10 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps11 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps12 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps13 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps14 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps15 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps16 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps17 "10000.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency0 "220.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency1 "110.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency2 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency3 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency4 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range0 "219.444444 219.642857 219.753086 220.0 220.3125 220.37037"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range1 "103.529412 104.210526 104.761905 110.0 115.789474 116.470588"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range2 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range3 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range4 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range17 "100.0"
dict set ::pll_all_ip_params gui_ps_units0 "ps"
dict set ::pll_all_ip_params gui_ps_units1 "ps"
dict set ::pll_all_ip_params gui_ps_units2 "ps"
dict set ::pll_all_ip_params gui_ps_units3 "ps"
dict set ::pll_all_ip_params gui_ps_units4 "ps"
dict set ::pll_all_ip_params gui_ps_units5 "ps"
dict set ::pll_all_ip_params gui_ps_units6 "ps"
dict set ::pll_all_ip_params gui_ps_units7 "ps"
dict set ::pll_all_ip_params gui_ps_units8 "ps"
dict set ::pll_all_ip_params gui_ps_units9 "ps"
dict set ::pll_all_ip_params gui_ps_units10 "ps"
dict set ::pll_all_ip_params gui_ps_units11 "ps"
dict set ::pll_all_ip_params gui_ps_units12 "ps"
dict set ::pll_all_ip_params gui_ps_units13 "ps"
dict set ::pll_all_ip_params gui_ps_units14 "ps"
dict set ::pll_all_ip_params gui_ps_units15 "ps"
dict set ::pll_all_ip_params gui_ps_units16 "ps"
dict set ::pll_all_ip_params gui_ps_units17 "ps"
dict set ::pll_all_ip_params gui_phase_shift0 "0.0"
dict set ::pll_all_ip_params gui_phase_shift1 "0.0"
dict set ::pll_all_ip_params gui_phase_shift2 "0.0"
dict set ::pll_all_ip_params gui_phase_shift3 "0.0"
dict set ::pll_all_ip_params gui_phase_shift4 "0.0"
dict set ::pll_all_ip_params gui_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg0 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg1 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg2 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg3 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg4 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift0 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift1 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range0 "0.0 56.8 63.1 71.0 81.2 94.7"
dict set ::pll_all_ip_params gui_actual_phase_shift_range1 "0.0 56.8 63.1 71.0 81.2 94.7"
dict set ::pll_all_ip_params gui_actual_phase_shift_range2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg0 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg1 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range0 "0.0 4.5 5.0 5.6 6.4 7.5"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range1 "0.0 2.3 2.5 2.8 3.2 3.8"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range17 "0.0"
dict set ::pll_all_ip_params gui_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle1 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle3 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle1 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle3 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range0 "43.75 44.44 45.0 50.0 55.0 55.56"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range1 "46.88 47.22 47.5 50.0 52.5 52.78"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range2 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range3 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range4 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range17 "50.0"
dict set ::pll_all_ip_params gui_simulation_type "true"
dict set ::pll_all_ip_params parameterTable_names "{M-Counter Divide Setting} {N-Counter Divide Setting} {VCO Frequency} {C-Counter-0 Divide Setting} {C-Counter-1 Divide Setting} {C-Counter-2 Divide Setting} {C-Counter-3 Divide Setting} {C-Counter-4 Divide Setting} {C-Counter-5 Divide Setting} {C-Counter-6 Divide Setting} {C-Counter-7 Divide Setting} {C-Counter-8 Divide Setting} {PLL Auto Reset} {M-Counter Hi Divide} {M-Counter Lo Divide} {M-Counter Even Duty Enable} {M-Counter Bypass Enable} {N-Counter Hi Divide} {N-Counter Lo Divide} {N-Counter Even Duty Enable} {N-Counter Bypass Enable} {C-Counter-0 Hi Divide} {C-Counter-1 Hi Divide} {C-Counter-2 Hi Divide} {C-Counter-3 Hi Divide} {C-Counter-4 Hi Divide} {C-Counter-5 Hi Divide} {C-Counter-6 Hi Divide} {C-Counter-7 Hi Divide} {C-Counter-8 Hi Divide} {C-Counter-0 Lo Divide} {C-Counter-1 Lo Divide} {C-Counter-2 Lo Divide} {C-Counter-3 Lo Divide} {C-Counter-4 Lo Divide} {C-Counter-5 Lo Divide} {C-Counter-6 Lo Divide} {C-Counter-7 Lo Divide} {C-Counter-8 Lo Divide} {C-Counter-0 Even Duty Enable} {C-Counter-1 Even Duty Enable} {C-Counter-2 Even Duty Enable} {C-Counter-3 Even Duty Enable} {C-Counter-4 Even Duty Enable} {C-Counter-5 Even Duty Enable} {C-Counter-6 Even Duty Enable} {C-Counter-7 Even Duty Enable} {C-Counter-8 Even Duty Enable} {C-Counter-0 Bypass Enable} {C-Counter-1 Bypass Enable} {C-Counter-2 Bypass Enable} {C-Counter-3 Bypass Enable} {C-Counter-4 Bypass Enable} {C-Counter-5 Bypass Enable} {C-Counter-6 Bypass Enable} {C-Counter-7 Bypass Enable} {C-Counter-8 Bypass Enable} {C-Counter-0 Preset} {C-Counter-1 Preset} {C-Counter-2 Preset} {C-Counter-3 Preset} {C-Counter-4 Preset} {C-Counter-5 Preset} {C-Counter-6 Preset} {C-Counter-7 Preset} {C-Counter-8 Preset} {C-Counter-0 Phase Mux Preset} {C-Counter-1 Phase Mux Preset} {C-Counter-2 Phase Mux Preset} {C-Counter-3 Phase Mux Preset} {C-Counter-4 Phase Mux Preset} {C-Counter-5 Phase Mux Preset} {C-Counter-6 Phase Mux Preset} {C-Counter-7 Phase Mux Preset} {C-Counter-8 Phase Mux Preset} {Charge Pump Current} {Bandwidth Control}"
dict set ::pll_all_ip_params parameterTable_values "22 1 {2200.0 MHz} 10 20 1 1 1 1 1 1 1 false 11 11 false false 256 256 false true 5 10 256 256 256 256 256 1 1 5 10 256 256 256 256 256 1 1 false false false false false false false false false false false true true true true true true true 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 pll_cp_setting15 pll_bw_res_setting3"
dict set ::pll_all_ip_params mifTable_names "{The MIF file specified does not yet exist}"
dict set ::pll_all_ip_params pll_m_cnt_basic "1"
dict set ::pll_all_ip_params pll_m_cnt "1"
dict set ::pll_all_ip_params prot_mode "BASIC"
dict set ::pll_all_ip_params protocol_mode "PROTOCOL_MODE_BASIC"
dict set ::pll_all_ip_params m_cnt_hi_div "11"
dict set ::pll_all_ip_params eff_m_cnt "1"
dict set ::pll_all_ip_params multiply_factor "22"
dict set ::pll_all_ip_params use_core_refclk "true"
dict set ::pll_all_ip_params m_cnt_lo_div "11"
dict set ::pll_all_ip_params n_cnt_hi_div "256"
dict set ::pll_all_ip_params n_cnt_lo_div "256"
dict set ::pll_all_ip_params m_cnt_bypass_en "false"
dict set ::pll_all_ip_params n_cnt_bypass_en "true"
dict set ::pll_all_ip_params m_cnt_odd_div_duty_en "false"
dict set ::pll_all_ip_params n_cnt_odd_div_duty_en "false"
dict set ::pll_all_ip_params pll_vco_div "1"
dict set ::pll_all_ip_params pll_cp_current "pll_cp_setting15"
dict set ::pll_all_ip_params pll_bwctrl "pll_bw_res_setting3"
dict set ::pll_all_ip_params pll_fractional_division "1"
dict set ::pll_all_ip_params fractional_vco_multiplier "false"
dict set ::pll_all_ip_params reference_clock_frequency "100.0 MHz"
dict set ::pll_all_ip_params pll_fractional_cout "1"
dict set ::pll_all_ip_params pll_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params operation_mode "direct"
dict set ::pll_all_ip_params number_of_clocks "2"
dict set ::pll_all_ip_params number_of_outclks "2"
dict set ::pll_all_ip_params pll_vcoph_div "1"
dict set ::pll_all_ip_params pll_type "Agilex 5"
dict set ::pll_all_ip_params pll_subtype "General"
dict set ::pll_all_ip_params pll_output_clk_frequency "2200.0 MHz"
dict set ::pll_all_ip_params pll_pfd_frequency "100.0 MHz"
dict set ::pll_all_ip_params mimic_fbclk_type "gclk"
dict set ::pll_all_ip_params pll_bw_sel "Medium"
dict set ::pll_all_ip_params pll_slf_rst "false"
dict set ::pll_all_ip_params pll_fbclk_mux_1 "pll_fbclk_mux_1_glb"
dict set ::pll_all_ip_params pll_fbclk_mux_2 "pll_fbclk_mux_2_m_cnt"
dict set ::pll_all_ip_params pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params pll_clkin_0_src "clk_0"
dict set ::pll_all_ip_params refclk1_frequency "0 MHz"
dict set ::pll_all_ip_params pll_clk_loss_sw_en "false"
dict set ::pll_all_ip_params pll_manu_clk_sw_en "false"
dict set ::pll_all_ip_params pll_auto_clk_sw_en "false"
dict set ::pll_all_ip_params pll_clkin_1_src "clk_0"
dict set ::pll_all_ip_params pll_clk_sw_dly "0"
dict set ::pll_all_ip_params pll_extclk_0_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_extclk_1_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_lock_fltr_cfg "100"
dict set ::pll_all_ip_params pll_unlock_fltr_cfg "2"
dict set ::pll_all_ip_params lock_mode "low_lock_time"
dict set ::pll_all_ip_params clock_to_compensate "0"
dict set ::pll_all_ip_params clock_name_global "false"
dict set ::pll_all_ip_params pll_freqcal_en "true"
dict set ::pll_all_ip_params pll_defer_cal_user_mode "true"
dict set ::pll_all_ip_params dprio_interface_sel "3"
dict set ::pll_all_ip_params merging_permitted "false"
dict set ::pll_all_ip_params bandwidth_mode "BANDWIDTH_MODE_AUTO"
dict set ::pll_all_ip_params compensation_clk_source "COMPENSATION_CLK_SOURCE_UNUSED"
dict set ::pll_all_ip_params compensation_mode "COMPENSATION_MODE_DIRECT"
dict set ::pll_all_ip_params cascade_mode "CASCADE_MODE_STANDALONE"
dict set ::pll_all_ip_params fb_clk_delay "0"
dict set ::pll_all_ip_params fb_clk_fractional_div_den "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_num "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_value "1"
dict set ::pll_all_ip_params fb_clk_m_div "0"
dict set ::pll_all_ip_params out_clk_cascading_source "OUT_CLK_CASCADING_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_0_source "OUT_CLK_EXTERNAL_0_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_1_source "OUT_CLK_EXTERNAL_1_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_periph_0_delay "0"
dict set ::pll_all_ip_params out_clk_periph_0_en "true"
dict set ::pll_all_ip_params out_clk_periph_1_delay "0"
dict set ::pll_all_ip_params out_clk_periph_1_en "true"
dict set ::pll_all_ip_params ref_clk_delay "0"
dict set ::pll_all_ip_params ref_clk_n_div "1"
dict set ::pll_all_ip_params set_dutycycle "SET_DUTYCYCLE_FRACTION"
dict set ::pll_all_ip_params set_fractional "SET_FRACTIONAL_FRACTION"
dict set ::pll_all_ip_params set_freq "SET_FREQ_DIVISION"
dict set ::pll_all_ip_params set_phase "SET_PHASE_NUM_SHIFTS"
dict set ::pll_all_ip_params pfd_clk_freq "100000000"
dict set ::pll_all_ip_params vco_clk_freq "1000000000"
dict set ::pll_all_ip_params c_cnt_hi_div0 "5"
dict set ::pll_all_ip_params c_cnt_hi_div1 "10"
dict set ::pll_all_ip_params c_cnt_hi_div2 "256"
dict set ::pll_all_ip_params c_cnt_hi_div3 "256"
dict set ::pll_all_ip_params c_cnt_hi_div4 "256"
dict set ::pll_all_ip_params c_cnt_hi_div5 "256"
dict set ::pll_all_ip_params c_cnt_hi_div6 "256"
dict set ::pll_all_ip_params c_cnt_hi_div7 "1"
dict set ::pll_all_ip_params c_cnt_hi_div8 "1"
dict set ::pll_all_ip_params c_cnt_hi_div9 "1"
dict set ::pll_all_ip_params c_cnt_hi_div10 "1"
dict set ::pll_all_ip_params c_cnt_hi_div11 "1"
dict set ::pll_all_ip_params c_cnt_hi_div12 "1"
dict set ::pll_all_ip_params c_cnt_hi_div13 "1"
dict set ::pll_all_ip_params c_cnt_hi_div14 "1"
dict set ::pll_all_ip_params c_cnt_hi_div15 "1"
dict set ::pll_all_ip_params c_cnt_hi_div16 "1"
dict set ::pll_all_ip_params c_cnt_hi_div17 "1"
dict set ::pll_all_ip_params c_cnt_lo_div0 "5"
dict set ::pll_all_ip_params c_cnt_lo_div1 "10"
dict set ::pll_all_ip_params c_cnt_lo_div2 "256"
dict set ::pll_all_ip_params c_cnt_lo_div3 "256"
dict set ::pll_all_ip_params c_cnt_lo_div4 "256"
dict set ::pll_all_ip_params c_cnt_lo_div5 "256"
dict set ::pll_all_ip_params c_cnt_lo_div6 "256"
dict set ::pll_all_ip_params c_cnt_lo_div7 "1"
dict set ::pll_all_ip_params c_cnt_lo_div8 "1"
dict set ::pll_all_ip_params c_cnt_lo_div9 "1"
dict set ::pll_all_ip_params c_cnt_lo_div10 "1"
dict set ::pll_all_ip_params c_cnt_lo_div11 "1"
dict set ::pll_all_ip_params c_cnt_lo_div12 "1"
dict set ::pll_all_ip_params c_cnt_lo_div13 "1"
dict set ::pll_all_ip_params c_cnt_lo_div14 "1"
dict set ::pll_all_ip_params c_cnt_lo_div15 "1"
dict set ::pll_all_ip_params c_cnt_lo_div16 "1"
dict set ::pll_all_ip_params c_cnt_lo_div17 "1"
dict set ::pll_all_ip_params c_cnt_prst0 "1"
dict set ::pll_all_ip_params c_cnt_prst1 "1"
dict set ::pll_all_ip_params c_cnt_prst2 "1"
dict set ::pll_all_ip_params c_cnt_prst3 "1"
dict set ::pll_all_ip_params c_cnt_prst4 "1"
dict set ::pll_all_ip_params c_cnt_prst5 "1"
dict set ::pll_all_ip_params c_cnt_prst6 "1"
dict set ::pll_all_ip_params c_cnt_prst7 "1"
dict set ::pll_all_ip_params c_cnt_prst8 "1"
dict set ::pll_all_ip_params c_cnt_prst9 "1"
dict set ::pll_all_ip_params c_cnt_prst10 "1"
dict set ::pll_all_ip_params c_cnt_prst11 "1"
dict set ::pll_all_ip_params c_cnt_prst12 "1"
dict set ::pll_all_ip_params c_cnt_prst13 "1"
dict set ::pll_all_ip_params c_cnt_prst14 "1"
dict set ::pll_all_ip_params c_cnt_prst15 "1"
dict set ::pll_all_ip_params c_cnt_prst16 "1"
dict set ::pll_all_ip_params c_cnt_prst17 "1"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst0 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst1 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst2 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst3 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst4 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst5 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst6 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst7 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst8 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst9 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst10 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst11 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst12 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst13 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst14 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst15 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst16 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst17 "0"
dict set ::pll_all_ip_params c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src9 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src10 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src11 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src12 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src13 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src14 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src15 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src16 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src17 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_bypass_en0 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en1 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en2 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en3 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en4 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en5 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en6 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en7 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en8 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en9 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en10 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en11 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en12 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en13 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en14 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en15 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en16 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en17 "true"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en0 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en1 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en2 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en3 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en4 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en5 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en6 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en7 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en8 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en9 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en10 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en11 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en12 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en13 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en14 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en15 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en16 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en17 "false"
dict set ::pll_all_ip_params output_clock_frequency0 "220.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency1 "110.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency2 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency3 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency4 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency5 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency6 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency7 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency8 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency9 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency10 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency11 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency12 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency13 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency14 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency15 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency16 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency17 "0 MHz"
dict set ::pll_all_ip_params phase_shift0 "0 ps"
dict set ::pll_all_ip_params phase_shift1 "0 ps"
dict set ::pll_all_ip_params phase_shift2 "0 ps"
dict set ::pll_all_ip_params phase_shift3 "0 ps"
dict set ::pll_all_ip_params phase_shift4 "0 ps"
dict set ::pll_all_ip_params phase_shift5 "0 ps"
dict set ::pll_all_ip_params phase_shift6 "0 ps"
dict set ::pll_all_ip_params phase_shift7 "0 ps"
dict set ::pll_all_ip_params phase_shift8 "0 ps"
dict set ::pll_all_ip_params phase_shift9 "0 ps"
dict set ::pll_all_ip_params phase_shift10 "0 ps"
dict set ::pll_all_ip_params phase_shift11 "0 ps"
dict set ::pll_all_ip_params phase_shift12 "0 ps"
dict set ::pll_all_ip_params phase_shift13 "0 ps"
dict set ::pll_all_ip_params phase_shift14 "0 ps"
dict set ::pll_all_ip_params phase_shift15 "0 ps"
dict set ::pll_all_ip_params phase_shift16 "0 ps"
dict set ::pll_all_ip_params phase_shift17 "0 ps"
dict set ::pll_all_ip_params duty_cycle0 "50"
dict set ::pll_all_ip_params duty_cycle1 "50"
dict set ::pll_all_ip_params duty_cycle2 "50"
dict set ::pll_all_ip_params duty_cycle3 "50"
dict set ::pll_all_ip_params duty_cycle4 "50"
dict set ::pll_all_ip_params duty_cycle5 "50"
dict set ::pll_all_ip_params duty_cycle6 "50"
dict set ::pll_all_ip_params duty_cycle7 "50"
dict set ::pll_all_ip_params duty_cycle8 "50"
dict set ::pll_all_ip_params duty_cycle9 "50"
dict set ::pll_all_ip_params duty_cycle10 "50"
dict set ::pll_all_ip_params duty_cycle11 "50"
dict set ::pll_all_ip_params duty_cycle12 "50"
dict set ::pll_all_ip_params duty_cycle13 "50"
dict set ::pll_all_ip_params duty_cycle14 "50"
dict set ::pll_all_ip_params duty_cycle15 "50"
dict set ::pll_all_ip_params duty_cycle16 "50"
dict set ::pll_all_ip_params duty_cycle17 "50"
dict set ::pll_all_ip_params clock_name_0 "outclk0"
dict set ::pll_all_ip_params clock_name_1 "outclk1"
dict set ::pll_all_ip_params clock_name_global_0 "false"
dict set ::pll_all_ip_params clock_name_global_1 "false"
dict set ::pll_all_ip_params clock_name_global_2 "false"
dict set ::pll_all_ip_params clock_name_global_3 "false"
dict set ::pll_all_ip_params clock_name_global_4 "false"
dict set ::pll_all_ip_params clock_name_global_5 "false"
dict set ::pll_all_ip_params clock_name_global_6 "false"
dict set ::pll_all_ip_params clock_name_global_7 "false"
dict set ::pll_all_ip_params clock_name_global_8 "false"
dict set ::pll_all_ip_params divide_factor0 "1"
dict set ::pll_all_ip_params divide_factor1 "1"
dict set ::pll_all_ip_params divide_factor2 "1"
dict set ::pll_all_ip_params divide_factor3 "1"
dict set ::pll_all_ip_params divide_factor4 "1"
dict set ::pll_all_ip_params divide_factor5 "1"
dict set ::pll_all_ip_params divide_factor6 "1"
dict set ::pll_all_ip_params divide_factor7 "1"
dict set ::pll_all_ip_params divide_factor8 "1"
dict set ::pll_all_ip_params out_clk_0_c_div "1"
dict set ::pll_all_ip_params out_clk_1_c_div "1"
dict set ::pll_all_ip_params out_clk_2_c_div "1"
dict set ::pll_all_ip_params out_clk_3_c_div "1"
dict set ::pll_all_ip_params out_clk_4_c_div "1"
dict set ::pll_all_ip_params out_clk_5_c_div "1"
dict set ::pll_all_ip_params out_clk_6_c_div "1"
dict set ::pll_all_ip_params out_clk_0_core_en "true"
dict set ::pll_all_ip_params out_clk_1_core_en "true"
dict set ::pll_all_ip_params out_clk_2_core_en "true"
dict set ::pll_all_ip_params out_clk_3_core_en "true"
dict set ::pll_all_ip_params out_clk_4_core_en "true"
dict set ::pll_all_ip_params out_clk_5_core_en "true"
dict set ::pll_all_ip_params out_clk_6_core_en "true"
dict set ::pll_all_ip_params out_clk_0_delay "0"
dict set ::pll_all_ip_params out_clk_1_delay "0"
dict set ::pll_all_ip_params out_clk_2_delay "0"
dict set ::pll_all_ip_params out_clk_3_delay "0"
dict set ::pll_all_ip_params out_clk_4_delay "0"
dict set ::pll_all_ip_params out_clk_5_delay "0"
dict set ::pll_all_ip_params out_clk_6_delay "0"
dict set ::pll_all_ip_params out_clk_0_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_1_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_2_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_3_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_4_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_5_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_6_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_0_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_1_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_2_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_3_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_4_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_5_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_6_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_0_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_1_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_2_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_3_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_4_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_5_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_6_phase_shifts "0"
dict set ::pll_all_ip_params ref_clk_0_freq "100000000"
dict set ::pll_all_ip_params ref_clk_1_freq "100000000"
dict set ::pll_all_ip_params out_clk_0_freq "1000000000"
dict set ::pll_all_ip_params out_clk_1_freq "1000000000"
dict set ::pll_all_ip_params out_clk_2_freq "1000000000"
dict set ::pll_all_ip_params out_clk_3_freq "1000000000"
dict set ::pll_all_ip_params out_clk_4_freq "1000000000"
dict set ::pll_all_ip_params out_clk_5_freq "1000000000"
dict set ::pll_all_ip_params out_clk_6_freq "1000000000"
dict set ::pll_all_ip_params out_clk_0_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_1_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_2_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_3_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_4_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_5_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_6_phase_ps "1000000000"
dict set ::pll_all_ip_params pll_tclk_mux_en "false"
dict set ::pll_all_ip_params pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params cal_converge "false"
dict set ::pll_all_ip_params cal_error "cal_clean"
dict set ::pll_all_ip_params pll_cal_done "false"
dict set ::pll_all_ip_params include_iossm "false"
dict set ::pll_all_ip_params cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params iossm_nios_sim_clk_period_ps "1333"
dict set ::pll_all_ip_params hp_number_of_family_allowable_clocks "9"
dict set ::pll_all_ip_params hp_previous_num_clocks "1"
dict set ::pll_all_ip_params hp_actual_vco_frequency_fp "600.0"
dict set ::pll_all_ip_params hp_qsys_scripting_mode "true"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp0 "220.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp1 "110.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp2 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp3 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp4 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp5 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp6 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp7 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp8 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp9 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp10 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp11 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp12 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp13 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp14 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp15 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp16 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp17 "100.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp0 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp1 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp2 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp3 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp4 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp5 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp6 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp7 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp8 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp9 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp10 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp11 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp12 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp13 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp14 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp15 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp16 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp17 "0.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp0 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp1 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp2 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp3 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp4 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp5 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp6 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp7 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp8 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp9 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp10 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp11 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp12 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp13 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp14 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp15 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp16 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp17 "50.0"
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 17 ed_synth_user_pll 17 altera_iopll_2000 5 synth 58 ed_synth_user_pll_altera_iopll_2000_q2hxwiy_parameters.tcl 7836 # PLL Parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!
#USER To ensure timing constraints and timing reports are correct, when you make 
#USER any changes to the PLL component using the Qsys,
#USER apply those changes to the PLL parameters in this file

set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename ed_synth_user_pll_altera_iopll_2000_q2hxwiy

set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data [dict create]
set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data [dict create]
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk pattern __inst_name__|tennm_ph2_iopll|ref_clk0
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk node_type pin
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk pin_id ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk pin_node_name ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk port_id ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk port_node_name ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk is_fpga_pin false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk is_main_refclk true
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk exists false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk name "__inst_name___refclk"
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk period 10.000
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data refclk half_period 5.000
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock pattern __inst_name__|tennm_ph2_iopll~ncntr_reg
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock node_type register
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock pin_id ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock is_valid false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock exists false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock name "__inst_name___n_cnt_clk"
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock src refclk
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock master ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock multiply_by 1
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock divide_by 1
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock phase 0.000
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data n_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock pattern __inst_name__|tennm_ph2_iopll~mcntr_reg
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock node_type register
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock pin_id ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock is_valid false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock exists false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock name "__inst_name___m_cnt_clk"
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock src refclk
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock master ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock multiply_by 1
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock divide_by 22
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock phase 0.000
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data m_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 pattern __inst_name__|tennm_ph2_iopll|out_clk\[0\]
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 node_type pin
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 pin_id ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 pin_node_name ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 is_valid false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 exists false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 name __inst_name___outclk0
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 src refclk
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 master ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 multiply_by 22
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 divide_by 10
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 phase 0.000
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 duty_cycle 50
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk0 counter_index 0
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 pattern __inst_name__|tennm_ph2_iopll|out_clk\[1\]
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 node_type pin
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 pin_id ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 pin_node_name ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 is_valid false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 exists false
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 name __inst_name___outclk1
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 src refclk
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 master ""
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 multiply_by 22
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 divide_by 20
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 phase 0.000
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 duty_cycle 50
dict set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data outclk1 counter_index 1
 10 0 2 C: 10 LPDDR_test 13 baseline_3906 3 qii 2 ip 8 ed_synth 17 ed_synth_user_pll 17 altera_iopll_2000 5 synth 55 ed_synth_user_pll_altera_iopll_2000_q2hxwiy_pin_map.tcl 50961 # (C) 2001-2025 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the traversal routines that are used by
# ed_synth_user_pll_altera_iopll_2000_q2hxwiy.sdc scripts. 
#
# These routines are only meant to support the SDC. 
# Trying to using them in a different context can have unexpected 
# results.

set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_debug 0

set script_dir [file dirname [info script]]

source [file join $script_dir ed_synth_user_pll_altera_iopll_2000_q2hxwiy_parameters.tcl]

proc get_warnings_disabled {} {
    set local_disable_warnings true
    set inis [split [get_global_assignment -name INI_VARS] ";"]
    foreach ini $inis {
        set ini_lst [split $ini "="]
        lassign $ini_lst ini_name ini_value
        if {$ini_name == "disable_warnings" && $ini_value == "off"} {
            set local_disable_warnings false
            break
        }
    }
    return $local_disable_warnings 
}
set ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_disable_warnings [get_warnings_disabled]

proc ai_get_timequest_name { full_hier_name } {
    # Input: lib1:inst1|lib2:inst2|lib3:inst3
    # Output: inst1|inst2|inst3
    set tq_name ""
    set tq_name_list {}
    set lib_inst_pair_list [split $full_hier_name "|"]

    foreach i_lib_inst_pair_str $lib_inst_pair_list {
        set i_lib_inst_pair [split $i_lib_inst_pair_str ":"]

        if {[llength $i_lib_inst_pair] > 1} {
            # take the 2nd element and onwards
            lappend tq_name_list [join [lrange $i_lib_inst_pair 1 end] :]
        } else {
            # if there is only 1 element, probably the last hierarchy which is a port or something like that.
            lappend tq_name_list [lindex $i_lib_inst_pair end]
        }
    }

    set tq_name [join $tq_name_list "|"]
    return $tq_name
}

# ----------------------------------------------------------------
#
proc ai_post_message {msg_type msg {msg_context sta_only}} {
#
# Description: Posts a message to Quartus, depending on 
# msg_context (sta_only, all)
#              
#              
#
# ----------------------------------------------------------------

    if {$msg_type == "debug"} {
        if {$::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_debug} {
            puts $msg
        }
    } else {
        if {$msg_context == "all"} {
            post_message -type $msg_type $msg
        } elseif {$msg_context == "sta_only"} {
            if {$::TimeQuestInfo(nameofexecutable) == "quartus_sta"} {
                post_message -type $msg_type $msg
            }
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_are_entity_names_on { } {
#
# Description: Determines if the entity names option is on
#
# ----------------------------------------------------------------
    return [set_project_mode -is_show_entity]    
}

# ----------------------------------------------------------------
#
proc ai_initialize_pll_db { pll_db_par } {
#
# Description: Gets the instances of this particular PLL IP and creates the pin
#              cache
#
# ----------------------------------------------------------------
    upvar $pll_db_par local_pll_db

    global ::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename

    ai_post_message info "Initializing PLL database for CORE $::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename"
    set instance_list [ai_get_core_instance_list $::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename]

    foreach instname $instance_list {
        ai_post_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename INSTANCE: $instname"

        # Some PLL atoms get merged and are no longer present
        if { [ai_get_pll_atom $instname] eq "" } { continue }

        set clock_data_dicts [ai_get_pll_pins $instname]
        lassign $clock_data_dicts base_clock_data_dict gen_clock_data_dict
        print_clock_data $base_clock_data_dict
        print_clock_data $gen_clock_data_dict 

        set local_pll_db($instname) $clock_data_dicts 
    }
}

# ----------------------------------------------------------------
#
proc ai_get_core_instance_list {corename} {
#
# Description: Converts node names from one style to another style
#
# ----------------------------------------------------------------
    set full_instance_list [ai_get_core_full_instance_list $corename]
    set instance_list [list]

    foreach inst $full_instance_list {
        if {[lsearch $instance_list [escape_brackets $inst]] == -1} {
            ai_post_message debug "Found instance:  $inst"
            lappend instance_list $inst
        }
    }
    return $instance_list
}

# ----------------------------------------------------------------
#
proc ai_get_core_full_instance_list {corename} {
#
# Description: Finds the instances of the particular IP by searching through the cells
#
# ----------------------------------------------------------------
    set instance_list [list]

    set instance_list_pre [design::get_instances -entity $corename]

    foreach instance $instance_list_pre {
        lappend instance_list [ai_get_timequest_name $instance]
    }

    if {[ llength $instance_list ] == 0} {

        if {!$::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_disable_warnings} {
            ai_post_message warning "The auto-constraining script was not able to detect any instance for core < $corename >" all
            ai_post_message warning "Verify the following:"
            ai_post_message warning " The core < $corename > is instantiated within another component (wrapper)" all
            ai_post_message warning " The core is not the top-level of the project" all
        }
    }

    return $instance_list
}
proc ai_get_registers {pattern} {
    if {$::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_disable_warnings} {
        return [get_registers -nowarn -no_duplicates $pattern]
    } else {
        return [get_registers -no_duplicates $pattern]
    }
}
proc ai_get_pins {pattern} {
    if {$::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_corename_disable_warnings} {
        return [get_pins -nowarn -no_duplicates $pattern]
    } else {
        return [get_pins -no_duplicates $pattern]
    }
}
proc ai_get_pin_node_name {pattern} {
    set pin_collection [ai_get_pins $pattern]
    set num_pins [get_collection_size $pin_collection]
    if {$num_pins == 1} {
        foreach_in_collection id $pin_collection {
            set node_name [get_node_info -name $id]         
            return $node_name
        }
    } 
    return ""
 
}

# ----------------------------------------------------------------
#
proc ai_get_collection_size_from_pattern {pattern} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    set pin_collection [get_pins -no_duplicates $pattern]
    return [get_collection_size $pin_collection]
}

# ----------------------------------------------------------------
#
proc print_clock_data {d} {
#
# Description: Prints clock data dict
#
# ---------------------------------------------------------------- 
    dict for {clock_key info} $d {
        ai_post_message debug "Clock:  $clock_key"
        dict for {key val} $info {
            ai_post_message debug "   $key: $val"
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_subst_instname {clock_data_dict patt} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            regsub -all "__inst_name__" $name $patt new_name
            regsub -all "__inst_name__" $pattern $patt new_pattern
            
            dict set clock_data_dict $clock_key name $new_name
            dict set clock_data_dict $clock_key pattern $new_pattern
            
            if {[dict exists $clock_data_dict $clock_key "through_pin" ]} {
                regsub -all "__inst_name__" $through_pin $patt new_through_pin
                dict set clock_data_dict $clock_key through_pin $new_through_pin
            }
        }
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_update_genclk_div_mult {clock_data_dict pll_parameters_dict} {
#
# Description: Updates the dict with div/mult values collected from
# the PLL's atom parameters.
#
# ----------------------------------------------------------------
    set compensated_counter_div 0
    set clock_to_compensate [dict get $pll_parameters_dict clock_to_compensate]
    # Loop over dict to find the compensated counter's div value first.
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {[info exists counter_index]} { 
                set clk_string_length [string length $clock_to_compensate]
                set clock_to_compensate_index [string index $clock_to_compensate [expr {$clk_string_length - 1}] ]
                if {$counter_index == $clock_to_compensate_index} {
                    set compensated_counter_div [dict get $pll_parameters_dict c${counter_index}_total]
                }
            }
        }
        unset -nocomplain counter_index
    }
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Getting div/mult factors for clock $clock_key" 
            set ccnt -1
            if {[info exists counter_index]} {
                set ccnt [dict get $pll_parameters_dict c${counter_index}_total]
                set ccnt_dc [dict get $pll_parameters_dict duty_cycle${counter_index}]
            } else {
                set counter_index -1
                set ccnt_dc 50
            }
            set mult_div [ai_get_mult_div_factors \
                $clock_key \
                $src \
                [dict get $pll_parameters_dict n_total] \
                [dict get $pll_parameters_dict m_total] \
                $ccnt \
                $counter_index \
                $compensated_counter_div \
                [dict get $pll_parameters_dict compensation_mode] \
                [dict get $pll_parameters_dict clock_to_compensate]]

            lassign $mult_div mult div

            ai_post_message debug "Setting mult_div factors for: $clock_key to $mult/$div"

            dict set clock_data_dict $clock_key multiply_by $mult
            dict set clock_data_dict $clock_key divide_by $div
            dict set clock_data_dict $clock_key duty_cycle $ccnt_dc
        }
        unset -nocomplain counter_index
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_set_genclk_pin_info {clock_data_dict} {
#
# Description: Updates the dict with pin info collected from making
# STA API calls.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            if {$node_type == "register"} {
                set pin_collection [ai_get_registers $pattern]
            } elseif {$node_type == "pin"} {
                set pin_collection [ai_get_pins $pattern]
            } else {
                ai_post_message "debug" "Incorrect type of node."
            }
            set num_pins [get_collection_size $pin_collection]
            if {$num_pins == 1} {
                # Always set valid to true if we found the pin node
                ai_post_message debug "Setting clock as valid."
                dict set clock_data_dict $clock_key is_valid true
                
                # This for loop should only loop once.
                foreach_in_collection id $pin_collection {
                    set node_name [get_node_info -name $id]         
                    dict set clock_data_dict $clock_key pin_id $id
                    dict set clock_data_dict $clock_key pin_node_name $node_name
                }
                # Check if clock_exists, if it does, then
                # set key "exists" on the clock info dict.
                dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

            
            } else {
                dict set clock_data_dict $clock_key is_valid false
            }

        }
    }
    return $clock_data_dict
    
    
} 
# ----------------------------------------------------------------
#
proc ai_set_baseclk_pin_info {clock_data_dict refclk_data_dict} {
#
    # Description: Updates the dict with pin info collected from refclk data
    # dict, which was obtained by traversing netlist.
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_set_baseclk_pin_info"

    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            
            # For each clock in refclk dict, find the one whose pin name
            # matches the pattern in baseclk dict. WE need to do this since
            # we dont find refclk nodes with patterns, but rather by traversal
            # of netlist from outclk backwards.
            
            set node_name ""
            dict for {clock_id info} $refclk_data_dict {
                dict with info {
                    ai_post_message debug "Comparing pattern $pattern with refclock: $ref_pin_node_name"
                    if {[string equal -nocase $pattern $ref_pin_node_name]} {
                        dict set clock_data_dict $clock_key pin_id $ref_pin_id
                        dict set clock_data_dict $clock_key pin_node_name $ref_pin_node_name
                        dict set clock_data_dict $clock_key port_id $ref_port_id
                        dict set clock_data_dict $clock_key port_node_name $ref_port_node_name
                        dict set clock_data_dict $clock_key is_fpga_pin $ref_is_fpga_pin
                        set node_name $ref_port_node_name
                        break
                    }
                }
            }
            # Check if clock_exists, if it does, then
            # set key "exists" on the clock info dict.
            dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

        }
    }
    return $clock_data_dict   
}

proc ai_get_n_cnt_clock_node_name {gen_clock_data_dict} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Clock:  $clock_key, pin_node_name: $pin_node_name"

            if {$clock_key == "n_cnt_clock"} {
                return $pin_node_name
            }
        }
    }
    return ""
}

proc ai_get_m_cnt_clock_node_name {gen_clock_data_dict} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Clock:  $clock_key, pin_node_name: $pin_node_name"
            if {$clock_key == "m_cnt_clock"} {
                return $pin_node_name
            }
        }
    }
    return ""
}

proc ai_get_compensated_clock_node_name {gen_clock_data_dict clock_to_compensate} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            if {[info exists counter_index]} { 
                set clk_string_length [string length $clock_to_compensate]
                set clock_to_compensate_index [string index $clock_to_compensate [expr {$clk_string_length - 1}] ]
                if {$counter_index == $clock_to_compensate_index} {
                    return $pin_node_name
                }
            }
        }
    }
    return ""
}
# ----------------------------------------------------------------
#
proc ai_update_baseclk_data {base_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the refclk information based on atom settings
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_baseclk_data_dict"
    set mode [dict get $pll_parameters_dict prot_mode]

    dict for {base_clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_main_refclk} {
                set ref_period [dict get $pll_parameters_dict refclk_period]
                if {[string match "*UIB" $mode]} {
                    set ref_period [expr ceil($ref_period * 1000.0)/1000.0]
                } else {
                    set ref_period [expr round($ref_period * 1000.0)/1000.0] 
                }
                set ref_period [format %.3f $ref_period]
                dict set base_clock_data_dict $base_clock_key period $ref_period

                set half_period [expr $ref_period /2]
                if {[string match "*UIB" $mode]} {
                    set half_period [expr ceil($half_period * 1000.0)/1000.0] 
                } else {
                    set half_period [expr round($half_period * 1000.0)/1000.0] 
                }
                set half_period [format %.3f $half_period]
                dict set base_clock_data_dict $base_clock_key half_period $half_period

            }
        }
    }

    return $base_clock_data_dict
}

# ----------------------------------------------------------------
#
proc ai_update_genclk_sources {base_clock_data_dict gen_clock_data_dict pll_parameters_dict} {
#
# Description: Updates the genclk data dict with src nodes from the appropriate
#              refclks
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_genclk_sources"

    # Set it to either refclk or n_cnt_clock
    # Don't use vcoph anymore (HSD 14017082319)
    set compensation_mode [dict get $pll_parameters_dict compensation_mode]
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Setting src pin info for clock $clock_key"

            set node_name ""
            set main_refclk_key ""
            dict for {base_clock_key base_clock_data_dict_info} $base_clock_data_dict {
                dict with base_clock_data_dict_info {
                    if {$is_main_refclk} {
                        set main_refclk_key $base_clock_key
                        if {$is_fpga_pin} {
                            set node_name $port_node_name
                        } else {
                            set node_name $pin_node_name
                        }
                        break
                    }
                }
            }
            if {$clock_key == "extclk0" && $fbclk} {
                set src "m_cnt_clock"
            } elseif {$clock_key == "m_cnt_clock" && ($compensation_mode == "COMPENSATION_MODE_NON_DEDICATED_SOURCE_SYNC" || $compensation_mode == "COMPENSATION_MODE_NON_DEDICATED_NORMAL")} {
                # in non-dedicated feedback mode, set the m-counter's source to the compensated(last) c counter
                set src "compensated_c_cnt_clock"
            } elseif {$clock_key != "n_cnt_clock" && ![dict get $pll_parameters_dict n_bypass]} {
                set src "n_cnt_clock"
            }

            if {$src == "refclk" || $src == "cascade_in"} {
                set src_ $node_name
            } elseif {$src == "n_cnt_clock"} {
                if {[is_post_syn_sta]} {
                    set gen_clock_data_dict_for_post_syn $gen_clock_data_dict
                    dict for {clk_key gen_clock_data_dict_for_post_syn_info} $gen_clock_data_dict_for_post_syn {
                        if {$clk_key == "n_cnt_clock"} {
                            dict set gen_clock_data_dict $clock_key master [dict get $gen_clock_data_dict_for_post_syn_info name]
                        }
                    }
                } else {
                    set src_ [ai_get_n_cnt_clock_node_name $gen_clock_data_dict]
                }
            } elseif {$src == "m_cnt_clock"} {
                    set src_ [ai_get_m_cnt_clock_node_name $gen_clock_data_dict]
            } elseif {$src == "compensated_c_cnt_clock"} {
                set clock_to_compensate [dict get $pll_parameters_dict clock_to_compensate]
                set src_ [ai_get_compensated_clock_node_name $gen_clock_data_dict $clock_to_compensate]
            } else {
                set src_ ""
                ai_post_message "warning" "Undefined clock source: $src"
                dict set gen_clock_data_dict $clock_key is_valid false
            }

            dict set gen_clock_data_dict $clock_key src $src_
        }
    }
    return $gen_clock_data_dict
}
proc ai_invalidate_clocks {clock_data_dict} {
    # Set the is_valid flag on each clock to false
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            dict set clock_data_dict $clock_key is_valid false
        }
    }
    return $clock_data_dict
}
proc ai_get_first_outclk_node {clock_data_dict} {
    set outclk_pin_id "None"
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {$node_type == "pin" && $is_valid} {
                set outclk_pin_id $pin_id
                break
            }
        }
    }
    if {$outclk_pin_id == "None"} {
        ai_post_message "warning" "Could not find any valid outclks"
    }
    return $outclk_pin_id 
}
# ----------------------------------------------------------------
#
proc ai_get_pll_pins { instname } {
#
# Description: Stores the pins of interest for the instance of the IP
#
# ----------------------------------------------------------------

    set base_clock_data_dict $::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_base_clock_data
    set gen_clock_data_dict $::GLOBAL_top_ed_synth_user_pll_altera_iopll_2000_q2hxwiy_gen_clock_data
    # First regsub the instance name for the pin names and patterns.
    set base_clock_data_dict [ai_subst_instname $base_clock_data_dict $instname]
    set gen_clock_data_dict [ai_subst_instname $gen_clock_data_dict $instname]


    set pll_parameters_dict [ai_get_pll_atom_parameters $instname] 
    set gen_clock_data_dict [ai_set_genclk_pin_info $gen_clock_data_dict]

    ai_post_message debug "gen_clock_data_dict initial: "
    print_clock_data $gen_clock_data_dict 
    
    # Traverse the first generated clock back to find FPGA pins for refclks.
    set outclk_node_id [ai_get_first_outclk_node $gen_clock_data_dict]
    if {$outclk_node_id != "None"} {
        set refclk_data_dict [ai_get_input_clk_info $outclk_node_id]
        ai_post_message debug "refclk_data_dict: "
        print_clock_data $refclk_data_dict

        set base_clock_data_dict [ai_set_baseclk_pin_info $base_clock_data_dict $refclk_data_dict]
        set gen_clock_data_dict [ai_update_genclk_sources $base_clock_data_dict $gen_clock_data_dict $pll_parameters_dict]
        set gen_clock_data_dict [ai_update_genclk_div_mult $gen_clock_data_dict $pll_parameters_dict] 
        set base_clock_data_dict [ai_update_baseclk_data $base_clock_data_dict $pll_parameters_dict] 
        ai_post_message debug "base_clock_data_dict: "
        print_clock_data $base_clock_data_dict 
        ai_post_message debug "gen_clock_data_dict final: "
        print_clock_data $gen_clock_data_dict
    } else {
        # Make sure that we don't create any clock constraints
        # if no output clock was found
        set gen_clock_data_dict [ai_invalidate_clocks $gen_clock_data_dict]
    }
    
    return [list $base_clock_data_dict $gen_clock_data_dict]
    
}

# ----------------------------------------------------------------
#
proc ai_get_input_clk_info { outclk_pin_id } {
#
# Description: Searches back from the output of the PLL to find the reference clock pin.
#              If the reference clock is fed by an input buffer, it finds that pin, otherwise
#              in cascading modes it will return the immediate reference clock input of the PLL.
#
# ----------------------------------------------------------------
    if {[ai_is_node_type_pll_clk $outclk_pin_id]} {
        #stores the refclk pin ids that were found by tracing the 
        #output clocks back up
        array set refclk_array [list]
        ai_traverse_fanin_up_to_depth $outclk_pin_id ai_is_node_type_pll_inclk clock refclk_array 20
        array set refclk_info_array [list]
        foreach {net_id id} [array get refclk_array] {
            set net_name [get_node_info -name $net_id]
            set refclk_info_array($net_id) $net_name

        }
        # Dict to hold the refclk info found by traversing the netlist back.
        # refclk_data = {
        #   clock_id = {
        #       ref_pin_id: str,
        #       ref_pin_node_name: str,
        #       ref_port_id: str,
        #       ref_port_node_name: str,
        #       ref_is_fpga_pin: true/false,
        #   }
        # }
        set refclk_data [dict create]
        
        set clock_id 0

        #only works if there is either 1 or 2 refclks
        if {[array size refclk_array] == 1 || [array size refclk_array] == 2} {
            #iterate over each refclk pin and trace back to find its input port
            foreach refclk_pin_id [array names refclk_info_array] {
                array set user_refclk_array [list]
                array unset refclk_array
                array unset user_refclk_array [list]
                     
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_user_clock clock user_refclk_array 10
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_pin clock refclk_array 10
                     
                # If fed by any user specified clock (which could be specified at the pin level or at the
                # buffer level), then use that pin as the source.
                # Otherwise, trace back to the dedicated input pin (depth 10 so that we don't include global clocks)
                if {[array size user_refclk_array] == 1 || [array size refclk_array] < 1} {
                    # Fed by a user specified clock, a global clock etc. 
                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id ""
                    dict set refclk_data $clock_id ref_port_node_name ""
                    dict set refclk_data $clock_id ref_is_fpga_pin false
                } else {
                    # Fed by a dedicated input pin
                    set port_id_ [lindex [array names refclk_array] 0]

                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id $port_id_
                    dict set refclk_data $clock_id ref_port_node_name [get_node_info -name $port_id_]
                    dict set refclk_data $clock_id ref_is_fpga_pin true
                }

                incr clock_id
            }
        } else {
            ai_post_message critical_warning "Could not find PLL ref clock that feeds [get_node_info -name $outclk_pin_id]" all
        }
    } else {
        ai_post_message error "Internal error: ai_get_input_clk_info only works for PLL output clocks" all
    }
    return $refclk_data
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pin { node_id } {
#
# Description: Determines if a node is a top-level port of the FPGA
#
# ----------------------------------------------------------------

    set node_type [get_node_info -type $node_id]
    if {$node_type == "port"} {
        set result 1
    } else {
        set result 0
    }
    return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_user_clock { node_id } {
#
# Description: Determines if a node is a user-defined clock
#
# ----------------------------------------------------------------
    set node_name [get_node_info -name $node_id]     
   
    if {[ai_clock_exists $node_name] && ![ai_is_node_type_pin $node_id]} {
        return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_clk { node_id } {
#
# Description: Determines if a node is an output of a PLL
#
# ----------------------------------------------------------------

    set cell_id [get_node_info -cell $node_id]
    
    if {$cell_id == ""} {
        set result 0
    } else {
        set atom_type [get_cell_info -atom_type $cell_id]
        if {$atom_type == "IOPLL"} {
            set node_name [get_node_info -name $node_id]
            ai_post_message debug "Node_name: $node_name"
            if {[string match "*fourteennm_pll\|outclk\\\[*\\\]" $node_name] || [string match "*tennm_pll\|outclk\\\[*\\\]" $node_name] || [string match "*tennm_ph2_iopll\|out_clk\\\[*\\\]" $node_name]} {
                set result 1
            } elseif {[string match "*fourteennm_pll~ncntr_reg" $node_name] || [string match "*tennm_pll~ncntr_reg" $node_name] || [string match "*tennm_ph2_iopll~ncntr_reg" $node_name]} {
                set result 1                
            } elseif {[string match "*fourteennm_pll~c*cntr_reg" $node_name] || [string match "*tennm_pll~c*cntr_reg" $node_name] || [string match "*tennm_ph2_iopll~c*cntr_reg" $node_name]} {
                set result 1                
            } elseif {[string match "*fourteennm_pll~mcntr_reg" $node_name] || [string match "*tennm_pll~mcntr_reg" $node_name] || [string match "*tennm_ph2_iopll~mcntr_reg" $node_name]} {
                set result 1                
            } elseif {[string match "*fourteennm_pll\|lvds_clk\\\[*\\\]" $node_name] || [string match "*tennm_pll\|lvds_clk\\\[*\\\]" $node_name]} {
                set result 1                
            } elseif {[string match "*fourteennm_pll\|loaden\\\[*\\\]" $node_name] || [string match "*tennm_pll\|loaden\\\[*\\\]" $node_name]} {
                set result 1
            } elseif {[string match "*tennm_ph2_iopll\|out_clk_periph0" $node_name]} {
                set result 1
            } elseif {[string match "*tennm_ph2_iopll\|out_clk_periph1" $node_name]} {
                set result 1
            } elseif {[string match "*tennm_ph2_iopll\|vco_clk_periph" $node_name]} {
                set result 1
            } elseif {[string match "*fourteennm_pll\|vcoph\\\[*\\\]" $node_name] || [string match "*tennm_pll\|vcoph\\\[*\\\]" $node_name] || [string match "*tennm_ph2_iopll\|vco_clk\\\[*\\\]" $node_name]} {
                set result 1
            } elseif {[string match "*fourteennm_pll\|pll_cascade_out" $node_name] || [string match "*tennm_pll\|pll_cascade_out" $node_name] || [string match "*tennm_ph2_iopll\|out_clk_cascade" $node_name]} {
                set result 1
            } elseif {[string match "*fourteennm_pll\|extclk_output\\\[*\\\]" $node_name] || [string match "*tennm_pll\|extclk_output\\\[*\\\]" $node_name] || [string match "*tennm_ph2_iopll\|out_clk_external*" $node_name]} {
                set result 1
            } else {
                set result 0
            }           
        } else {
            set result 0
        }
    }
    return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_inclk { node_id } {
#
# Description: Determines if a node is an input of a PLL
#
# ----------------------------------------------------------------


    set cell_id [get_node_info -cell $node_id]
    
    if {$cell_id == ""} {
        set result 0
    } else {
        set atom_type [get_cell_info -atom_type $cell_id]
        if {$atom_type == "IOPLL"} {
            set node_name [get_node_info -name $node_id]
            set fanin_edges [get_node_info -clock_edges $node_id]
            if {([string match "*|refclk\\\[*\\\]" $node_name] || [string match "*|ref_clk0" $node_name] || [string match "*|ref_clk1" $node_name])  && [llength $fanin_edges] > 0} {
                set result 1
            } elseif {([string match "*|pll_cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
                set result 1
            } else {
                set result 0
            }
        } else {
            set result 0
        }
    }
    return $result
}

# -----------------------------------------------------------------
#
proc ai_find_pll_inclk { match_command edge_type } {
#
# Desciption: Finds the pll inclk pin whose name matches the
#             match_command. Returns the inclk pin name if such
#             a pin is found, and returns "" if it is not found
#
# -----------------------------------------------------------------

    set fanin_id ""
    foreach_in_collection pin [get_pins $match_command] {
        if {[llength [get_node_info -${edge_type}_edges $pin]] > 0} {
            set fanin_id $pin
            break
        }
    }
    return $fanin_id
}

# ----------------------------------------------------------------
#
proc ai_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
#
# Description: General traversal function up until a depth.  Use a function pointer to decide
#              ending conditions.
#
# ----------------------------------------------------------------

    upvar 1 $results_array_name results

    if {$depth < 0} {
        error "Internal error: Bad timing netlist search depth"
    }

    ai_post_message debug "\[ai_traverse_fanin_up_to_depth\] called with node_id: $node_id cmd: \"$match_command\" type: $edge_type node: [get_node_info -name $node_id]"
    if {[is_post_syn_sta] && $match_command == "ai_is_node_type_pll_inclk"} {
        set atom_name [get_cell_info -name [get_node_info -cell $node_id]]
        set fanin_id [ai_find_pll_inclk $atom_name|core*refclk* $edge_type]
        if {$fanin_id == ""} {
            set fanin_id [ai_find_pll_inclk $atom_name|pll*cascade*in* $edge_type]
        }
        if {$fanin_id == ""} {
            set fanin_id [ai_find_pll_inclk $atom_name|ref*clk* $edge_type]
        }
        set results($fanin_id) 1
        ai_post_message debug "\[ai_traverse_fanin_up_to_depth\] post syn model returning fanin id: [get_node_info -name $fanin_id]"
        return
    }

    set fanin_edges [get_node_info -${edge_type}_edges $node_id]
    set number_of_fanin_edges [llength $fanin_edges]
    for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
        set fanin_edge [lindex $fanin_edges $i]
        set fanin_id [get_edge_info -src $fanin_edge]
        if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
            set results($fanin_id) 1
        } elseif {$depth == 0} {
        } else {
            ai_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_index_in_collection { col j } {
#
# Description: Returns a particular index in a collection.
#              Analagous to lindex for lists.
#
# ----------------------------------------------------------------

    set i 0
    foreach_in_collection path $col {
        if {$i == $j} {
            return $path
        }
        set i [expr $i + 1]
    }
    return ""
}

#
# Description: Rounds a given floating point number
#              to 3 decimal places
#
# ----------------------------------------------------------------
proc ai_round_3dp { x } {
    return [expr { round($x * 1000) / 1000.0  } ]
}

# ----------------------------------------------------------------
# Description: Checks whether a given clock already exists 
# ----------------------------------------------------------------
proc ai_clock_exists { clock_name } {
    set clock_found false
    set input_clocks_col [get_clocks -nowarn]
    set num_input_clocks [get_collection_size $input_clocks_col]
    
    if {$num_input_clocks > 0} {
        foreach_in_collection iclk $input_clocks_col {
            if {![is_clock_defined $iclk]} {
                continue
            }

            set clk_targets_col [get_clock_info -target $iclk]
            set num_clk_targets [get_collection_size $clk_targets_col]
            if {$num_clk_targets > 0} {
                foreach_in_collection itgt $clk_targets_col {
                    set node_name [get_node_info -name $itgt]
                    if {[string compare $node_name $clock_name] == 0} {
                        set clock_found true
                        break
                    }
                }
            }
            if {$clock_found == true} {
                break;
            }
        }
    }

   return $clock_found 
}

proc ai_get_pll_atom {instname} {
    foreach_in_collection node [get_atom_nodes -type IOPLL] {
        set name [ai_get_timequest_name [get_atom_node_info -key NAME -node $node]]
        set node_list($name) $node

        if {[string first $instname $name] > -1} {
            return $node
        }
    }
    set sdc_file_name [info script]
    ai_post_message warning "Could not find IOPLL atom with the name <$instname> while processing <$sdc_file_name>. Please check the synthesis report to ensure that the IOPLL was not synthesized away." all
}
proc ai_get_mult_div_factors {clock_key src ncnt mcnt ccnt counter_index \
                              compensated_counter_div compensation_mode \
                              clock_to_compensate} {
    if {$clock_key == "vcoph" || $clock_key == "vcoph_periph"} {
        set clock_mult $mcnt
        set clock_div 1
    } elseif {$clock_key == "n_cnt_clock"} {
        set clock_mult 1
        set clock_div $ncnt
    } elseif {$clock_key == "m_cnt_clock"} {
        set clock_mult 1
        set clock_div 1
    } else {

        if {[string first "vcoph" $src] > -1} {
            set clock_mult 1
            set clock_div $ccnt
        } else {
            # Handle NDFB mode. 
            # The equation for counter which is to be compensated: C_k = M / N
            # The equation for all other counters:                 C_!k = (M * C_k) / (N * C_!k)
            if {$compensation_mode == "COMPENSATION_MODE_NON_DEDICATED_SOURCE_SYNC" || $compensation_mode == "COMPENSATION_MODE_NON_DEDICATED_NORMAL"} {
                set clk_string_length [string length $clock_to_compensate]
                set clock_to_compensate_index [string index $clock_to_compensate [expr {$clk_string_length - 1}] ]
                if {$counter_index == $clock_to_compensate_index} {
                    set clock_mult $mcnt
                    # Instead of dividing by N, we just divide by 1
                    # since a clock based on the N counter would be created
                    # if N > 1 and this clock would be derived based on that,
                    # so we already have a division happening.
                    set clock_div 1
                } else {
                    set clock_mult [expr $mcnt * $compensated_counter_div]
                    set clock_div $ccnt
                }
            } else {
                ai_post_message debug "Normal C counter"
                set clock_mult $mcnt
                set clock_div $ccnt
            }
        }
    }
    return [list $clock_mult $clock_div]

}
# ----------------------------------------------------------------
#
proc ai_get_pll_atom_parameters {instname} {
#
# Description: Gets the PLL paramaters from the Quartus atom and not 
#              from the IP generated parameters.
#
# ----------------------------------------------------------------

    set pll_atom [ai_get_pll_atom $instname]
    
    set atom_type [get_atom_node_info -key ENUM_ATOM_TYPE -node $pll_atom]
    
    if {($atom_type == "TENNM_PH2_IOPLL")} {
                                                                             
        dict set pll_params compensation_mode [get_atom_node_info -key COMPENSATION_MODE -node $pll_atom]
        dict set pll_params clock_to_compensate [get_atom_node_info -key COMPENSATION_CLK_SOURCE -node $pll_atom]
        dict set pll_params prot_mode [get_atom_node_info -key PROTOCOL_MODE -node $pll_atom]

        # Get refclk frequency (might have changed since IP generation)
        set refclk_freq_bin [get_atom_node_info -key REF_CLK_0_FREQ -node $pll_atom]
        set refclk_freq_hz [expr "0b$refclk_freq_bin"]
    
        set refclk_period [expr 1000000000.0 / $refclk_freq_hz]
        dict set pll_params refclk_period $refclk_period

        dict set pll_params m_total [get_atom_node_info -key FB_CLK_M_DIV -node $pll_atom]
        if {[dict get $pll_params m_total] == 1} {
            dict set pll_params m_bypass 1
        } else {
            dict set pll_params m_bypass 0    
        }
        dict set pll_params n_total [get_atom_node_info -key REF_CLK_N_DIV -node $pll_atom]
        if {[dict get $pll_params n_total] == 1} {
            dict set pll_params n_bypass 1
        } else {
            dict set pll_params n_bypass 0    
        }


        for { set i 0 } { $i < 7} { incr i } {
            # Get the C counter parameter settings from the atom netlist
            dict set pll_params c${i}_total [get_atom_node_info -key OUT_CLK_${i}_C_DIV -node $pll_atom]
            dict set pll_params duty_cycle${i} [get_atom_node_info -key OUT_CLK_${i}_DUTYCYCLE_PERCENT -node $pll_atom]
        }
    } else {
        dict set pll_params compensation_mode [get_atom_node_info -key ENUM_IOPLL_FEEDBACK -node $pll_atom]
        dict set pll_params clock_to_compensate [get_atom_node_info -key INT_IOPLL_CLOCK_TO_COMPENSATE -node $pll_atom]
    
        # Get refclk frequency (might have changed since IP generation)
        set refclk_freq [get_atom_node_info -key TIME_REFERENCE_CLOCK_FREQUENCY -node $pll_atom]
        set refclk_int [string trim $refclk_freq "*MHZmhz"]
        set refclk_period [expr 1000.0 / $refclk_int]
        dict set pll_params refclk_period $refclk_period
    
        dict set pll_params m_hi_div [get_atom_node_info -key INT_IOPLL_M_CNT_HI_DIV -node $pll_atom]
        dict set pll_params m_lo_div [get_atom_node_info -key INT_IOPLL_M_CNT_LO_DIV -node $pll_atom]
        dict set pll_params m_bypass [get_atom_node_info -key BOOL_IOPLL_M_CNT_BYPASS_EN -node $pll_atom]
        if {[dict get $pll_params m_bypass]} {
            set total 1
        } else {
            set total  [expr [dict get $pll_params m_hi_div] + [dict get $pll_params m_lo_div]]
        }
        dict set pll_params m_total $total
    
        dict set pll_params n_hi_div [get_atom_node_info -key INT_IOPLL_N_CNT_HI_DIV -node $pll_atom]
        dict set pll_params n_lo_div [get_atom_node_info -key INT_IOPLL_N_CNT_LO_DIV -node $pll_atom]
        dict set pll_params n_bypass [get_atom_node_info -key BOOL_IOPLL_N_CNT_BYPASS_EN -node $pll_atom]
        if {[dict get $pll_params n_bypass]} {
            set total 1
        } else {
            set total  [expr [dict get $pll_params n_hi_div] + [dict get $pll_params n_lo_div]]
        }
        dict set pll_params n_total $total
    
        for { set i 0 } { $i < 9} { incr i } {
            # Get the C counter parameter settings from the atom netlist
            dict set pll_params c${i}_hi_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_HI_DIV -node $pll_atom]
            dict set pll_params c${i}_lo_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_LO_DIV -node $pll_atom]
            dict set pll_params c${i}_bypass [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_BYPASS_EN -node $pll_atom]
            dict set pll_params c${i}_odd_div_duty_en [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_EVEN_DUTY_EN -node $pll_atom]
    
            # Calculate the total counter value
            if {[dict get $pll_params c${i}_bypass]} {
                set total 1
            } else {
                set total [expr [dict get $pll_params c${i}_hi_div] + [dict get $pll_params c${i}_lo_div]]
            }
            dict set pll_params c${i}_total $total
    
            # Calculate the duty cycle
            if {[dict get $pll_params c${i}_bypass]} {
                set total_duty 50
            } else {
                if {[dict get $pll_params c${i}_odd_div_duty_en]} {
                    set duty_tweak 1
                } else {
                    set duty_tweak 0
                }
                set total_duty [expr (([dict get $pll_params c${i}_hi_div] - (0.5*$duty_tweak))*100)/$total]
                set total_duty [format %.3f $total_duty]
            }
            dict set pll_params duty_cycle${i} $total_duty
        }    
    }

    return $pll_params
}

#__ACDS_USER_COMMENT__Set max delay if in fit flow, otherwise set false path through "through_pin"
# originally in the LVDS SDC. This is called if we are exporting loaden to LVDS
proc set_max_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }
    
    # if fit_flow == 1
    if {$::TimeQuestInfo(nameofexecutable) == "quartus_fit" } { 
        set_max_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
}

# ----------------------------------------------------------------
#
proc is_m_n_cntr {pattern} {
#
# Description: Determines if a pattern matches m/n_cntr
#
# ----------------------------------------------------------------

    if {[string match "*fourteennm_pll~ncntr_reg" $pattern]||[string match "*tennm_pll~ncntr_reg" $pattern]||
        [string match "*fourteennm_pll~mcntr_reg" $pattern]||[string match "*tennm_pll~mcntr_reg" $pattern]||
        [string match "*tennm_ph2_iopll~ncntr_reg" $pattern]||[string match "*tennm_ph2_iopll~mcntr_reg" $pattern]} {
            return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc create_non_virtual_generated_clock_with_master_or_source \
{master source name multiply_by divide_by phase duty_cycle pin_node_name} {
#
# Description: Creates a non-virtual generated clock using
#              the -source or the -master argument
#
# ----------------------------------------------------------------
    if {$master != ""} {
        create_generated_clock -add \
            -master $master \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle \
            $pin_node_name
    } else {
        create_generated_clock -add \
            -source $source \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle \
            $pin_node_name
    }
}

# ----------------------------------------------------------------
#
proc create_virtual_generated_clock_with_master_or_source \
{master source name multiply_by divide_by phase duty_cycle} {
#
# Description: Creates a virtual generated clock using
#              the -source or the -master argument
#
# ----------------------------------------------------------------
    if {$master != ""} {
        create_generated_clock -add \
            -master $master \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle
    } else {
        create_generated_clock -add \
            -source $source \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle
    }
}

# ----------------------------------------------------------------
#
proc get_master_clock_given_refclk_src \
{refclk_src} {
#
# Description: Performs string comparisons to determine the master
#              clock that feeds a particular PLL refclk iterm
#              No comparison needed if there's only one master clock.
# ----------------------------------------------------------------
    set clocks [get_clocks -nowarn -of_objects $refclk_src]
    if {[get_collection_size $clocks] == 1} {
        foreach_in_collection clk $clocks {
            return $clk
        }
    } else {
        foreach_in_collection clk $clocks {
            set clk_name [get_clock_info -name $clk]
            set pll_path [regsub {[^|]+$} $clk_name ""]
            if {[string first $pll_path $refclk_src] == 0} {
                return $clk
            }
        }
    }
}
 1
